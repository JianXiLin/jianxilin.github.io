{"meta":{"title":"Jianxi's Blog","subtitle":"Learn to code and share","description":"","author":"JianxiLin","url":"https://jianxilin.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-05-10T16:01:52.000Z","updated":"2020-05-10T16:06:36.161Z","comments":true,"path":"categories/index.html","permalink":"https://jianxilin.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-10T16:02:27.000Z","updated":"2020-05-10T16:06:09.613Z","comments":true,"path":"tags/index.html","permalink":"https://jianxilin.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"RESTful API","slug":"RESTful-API","date":"2020-06-07T09:17:22.000Z","updated":"2020-06-07T09:21:35.986Z","comments":true,"path":"2020/06/07/RESTful-API/","link":"","permalink":"https://jianxilin.github.io/2020/06/07/RESTful-API/","excerpt":"REST为一种设计规范通过HTTP来描述操作,URL来定位资源","text":"REST为一种设计规范通过HTTP来描述操作,URL来定位资源 1. HTTP状态码 具体 类别 描述 1XX — 信息性 接受到请求且正在处理 2XX — 成功性 请求处理完毕 200 OK 请求成功 201 Created 创建成功 204 No Content 处理成功，但没返回实体内容，无消息体 3XX — 重定向性 需要进行附加操作来完成操作 300 Multiple Choice 提供多个内容可选择 4XX 4XX 客户端错误 服务端无法处理请求 400 Bad Requset 语义有误，参数有误 404 Not Found 未在服务器上找到相应的资源 405 Method Not Allowed 该请求方法不被允许，例如发送PUT请求到不支持PUT方法的服务器 409 Conflict 请求的资源发生冲突，返回请求时，需提供修改建议（eg : 差异比较） 5XX — 服务端错误 服务端处理请求出错 500 Internal Server Error 服务器不知如何处理该请求 504 Gateway Timeout 获取数据超时 PUT 与 POST：PUT被定义为idempotent（幂等）方法，而POST则不是即重复多个请求，PUT的相应结果是一致的，POST则不是。 header(“HTTP/1.0 409 Conflict”, true);true：已发送相同的header时，后续将与前面的结果一致。false：结果可不一致，即相同请求可并存。 2. RESTful设计规则 Method 操作 状态码 OPTIONS 询问该接口/端点支持哪些方法 200 OK POST Create创建 正常：201；异常：404、409 GET Read读取 正常：200；异常：404 HEAD Read（body为空） 正常：200；异常：404 PUT Replace替换 正常：200；异常：204、404、405 PATCH Update更新 正常：200；异常：204、404、405 DELETE delete 正常：200、202、204；异常：404、405 2.1. PATCH 与 PUT 🔹 PATCH为更新某资源的部分数据（部分），PUT则是更新某资源的全部数据（整体）🔹 但只需修改部分数据时，也可用PUT发送需修改的数据，来替换PATCH。 2.2. POST的成功响应 🔹 以HTTP标准而言，POST应返回的成功状态码为201。🔹 也可直接响应新建资源的所有数据。 2.3. DELETE的响应内容 🔹 状态码200 ：删除成功，返回删除的具体信息（含body：code+message+data）204 ：删除成功，无返回内容（无body）202 ：接受删除请求，未执行 3. 风格设计 3.1. 接口 🔹 不使用动词,使用名词,以请求方法来作为动词🔹 为了统一,名词尽量为复数🔹 避免多级URL。&emsp;除了第一级，其他级别都用查询字符串表达。&emsp;eg: GET /authors/12?categories=2&emsp;&emsp;GET /articles?published=true 3.2. 响应信息 1234567891011121314151617&#123; \"code\": xxx, \"message\": \"\", \"data\":&#123;&#125;&#125;// 分页响应结果的参数（可选）&#123; // 可放在data中或外部 \"page|currentPage\": xxx, // 当前页码 \"numPerPage\": xxx, // 每页个数 \"pages|totalPageNum\": xxx, // 总页数 \"total\": xxx, // 总个数 \"hasPrev\": boolean, // 是否有上一页 \"hasNext\": boolean, // 是否有下一页 \"items\" : &#123;&#125; // 列表数据内容&#125; 📘参考、摘取文章：RESTful API 最佳实践–阮一峰HTTP后台端：RESTful API接口设计","categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"name":"RESTful","slug":"个人笔记/RESTful","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/RESTful/"}],"tags":[{"name":"RESTful","slug":"RESTful","permalink":"https://jianxilin.github.io/tags/RESTful/"}]},{"title":"SpringCache的简单使用","slug":"SpringCache的简单使用","date":"2020-06-07T08:56:29.000Z","updated":"2020-06-07T09:05:20.831Z","comments":true,"path":"2020/06/07/SpringCache的简单使用/","link":"","permalink":"https://jianxilin.github.io/2020/06/07/SpringCache%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","excerpt":"1. 简述 &emsp;&emsp;为各个缓存技术提供一个接口规范。&emsp;&emsp;其中CacheManager是Spring提供的各种缓存技术抽象接口，Cache接口则提供缓存的相关操作。 🔹SpringBoot中的整合：&emsp;&emsp;在Springboot中则默认配置了多个CacheManager的实现，默认使用ConcurrenMapCacheManager。&emsp;&emsp;若使用多个CacheManager，则可通过注入实现CachingConfigurerSupport接口的配置类来设置。","text":"1. 简述 &emsp;&emsp;为各个缓存技术提供一个接口规范。&emsp;&emsp;其中CacheManager是Spring提供的各种缓存技术抽象接口，Cache接口则提供缓存的相关操作。 🔹SpringBoot中的整合：&emsp;&emsp;在Springboot中则默认配置了多个CacheManager的实现，默认使用ConcurrenMapCacheManager。&emsp;&emsp;若使用多个CacheManager，则可通过注入实现CachingConfigurerSupport接口的配置类来设置。 2. 结合Redis 2.1. 项目的创建 2.1. 使用redis 2.1.1. 在配置文件中配置基本信息 12345678//redis的相关配置spring.redis.host=106.15.72.132spring.redis.port=6379spring.redis.database=0spring.redis.password=//设置cahce名称spring.cache.cache-names=c1 2.1.2. 使用缓存 在将运用缓存的方法或类上添加相应的注解 @EnableCaching 在启动类注解@EnableCaching开启缓存 @Cacheable 标记哪个方法将使用缓存。默认方法所有方法为key,返回值为value。 主要参数如下： 🔹 cacheName指定缓存名称 🔹 key指定哪些内容作为缓存的key（默认为方法的所有参数） 取值 含义 案例 参数名 表示某个参数 method 该方法 #method、#method.name methodName 方法名称 #methodName args 方法参数 #args、#args[0] target 当前被调用的class #target caches 被调用的方法使用的缓存 #caches result 方法返回值（需先执行方法） #result condition 缓存添加，true时才进行缓存,使用SpEL #userName.length()&gt;2 12// 案例：指定参数名为id的值作为key@Cacheable(cacheNames = \"c1\",key = \"#id\") 🔹 keyGernerator自定义key先定义类，实现KeyGernerator接口，注入ioc容器。再通过该注解来指定。 12345678910111213141516// 自定义定义key@Componentpublic class MyKeyGernerator implements KeyGenerator &#123; /** * 设置 方法名-参数名 为key * @param o 当前被调用的对象 * @param method 方法 * @param objects 方法参数 * @return 方法名+参数名 */ @Override public Object generate(Object o, Method method, Object... objects) &#123; return method.getName()+\"-\"+ Arrays.toString(objects); &#125;&#125; 12// 指定自定义的key@Cacheable(cacheNames = \"c1\",keyGenerator = \"myKeyGernerator\") @CacheEvict 用于删除缓存。 特有的参数： 参数 含义 allEntries 是否删除所有缓存 beforeInvocation 是否先调用，即是否先删除缓存 12345//案例@CacheEvict(cacheNames = \"c1\",allEntries = false)public void deleteUserById(Integer id)&#123; System.out.println(\"&gt;&gt;&gt;deleteUserById()\");&#125; @CachePut 用于更新缓存，更新key值相同的缓存 12345@CachePut(cacheNames = \"c1\",key = \"#user.id\")public User updateUser(User user)&#123; System.out.println(\"&gt;&gt;&gt;updateUser()\"); return user;&#125; @CacheConfig 用于类上的注解，添加Cache的相关配置 特有的参数： 参数 含义 cacheNames 指定该类上的缓存使用的缓存名称 1@CacheConfig(cacheNames = \"c1\") @Caching 可用于使用多个注解,与其它Cache注解结合使用。 12345678@Caching(put = &#123; @CachePut(value = \"user\", key = \"#user.id\"), @CachePut(value = \"user\", key = \"#user.username\"), @CachePut(value = \"user\", key = \"#user.email\")&#125;)public User save(User user) &#123; .....&#125;","categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"个人笔记/Java","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/"},{"name":"SpringCache","slug":"个人笔记/Java/SpringCache","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/SpringCache/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jianxilin.github.io/tags/Java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://jianxilin.github.io/tags/SpringBoot/"},{"name":"Redis","slug":"Redis","permalink":"https://jianxilin.github.io/tags/Redis/"},{"name":"SpringCache","slug":"SpringCache","permalink":"https://jianxilin.github.io/tags/SpringCache/"}]},{"title":"SpringBoot整合SpringSecurity","slug":"SpringBoot整合SpringSecurity","date":"2020-06-07T08:33:33.000Z","updated":"2020-06-07T08:38:13.591Z","comments":true,"path":"2020/06/07/SpringBoot整合SpringSecurity/","link":"","permalink":"https://jianxilin.github.io/2020/06/07/SpringBoot%E6%95%B4%E5%90%88SpringSecurity/","excerpt":"1. jar包导入 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;","text":"1. jar包导入 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 2. 默认参数 导入SpringSecurity的jar包后，则生效。SpringSecurity默认拦截了所有请求，提供了表单登录，默认提供了一个User对象记录了默认的用户名、密码、角色等。 从SecuriryProperies类中可得出，用户名默认为user等信息。 123456789101112131415//SecuriryProperies类中的内部类public static class User &#123; /** * Default user name. */ private String name = \"user\"; /** * Password for the default user name. */ private String password = UUID.randomUUID().toString(); /** * Granted roles for the default user name. */ private List&lt;String&gt; roles = new ArrayList&lt;&gt;(); ... 可修改的自动配置参数： 12345678910111213# ----------------------------------------# SECURITY PROPERTIES# ----------------------------------------# SECURITY (SecurityProperties)spring.security.filter.order=0 # Security filter chain order.spring.security.filter.dispatcher-types=ASYNC,ERROR,REQUEST # Security filter chain dispatcher types.spring.security.user.name=user # Default user name.spring.security.user.password= # Password for the default user name.spring.security.user.roles= # Granted roles for the default user name.# SECURITY OAUTH2 CLIENT (OAuth2ClientProperties)spring.security.oauth2.client.provider.*= # OAuth provider details.spring.security.oauth2.client.registration.*= # OAuth client registrations. 3. 配置认证信息 SpringSecurity中认证信息的配置通过WebSecurityConfigurerAdapter接口内的configure(AuthenticationManagerBuilder auth)方法来配置。 3.1. 使用固定的认证信息 1234567@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.inMemoryAuthentication() .withUser(\"xi\").password(\"xi\").roles(\"admin\") .and() .withUser(\"ming\").password(\"ming\").roles(\"user\");&#125; 3.2. 使用数据库中的信息 在配置类中认证信息方法上，添加UserService类实例，该类需实现UserDetailsService接口,重写以下该方法：UserDetails loadUserByUsername(String var1) 该方法将返回的内容是与数据库相互映射的user实体类，其需实现UserDetails接口 🔹 配置类 1234567@AutowiredUserService userService;@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(userService);&#125; 🔹 service 12345678910111213141516@Servicepublic class UserService implements UserDetailsService &#123; @Autowired UserMapper userMapper; @Override public User loadUserByUsername(String username) &#123; User user = userMapper.loadUserByUsername(username); if (user == null) &#123; throw new UsernameNotFoundException(\"用户不存在\"); &#125; user.setRoles(userMapper.getRolesByUserId(user.getId())); return user; &#125;&#125; 🔹 user实体类 1234567891011public class User implements UserDetails &#123; private Integer id; private String username; private String password; private boolean enabled; private boolean locked; //是否被锁定 private List&lt;Role&gt; roles; ....&#125; 3.3. 密码加密 🔹 设置密码加密方式 可在配置类中注入PasswordEncoder类。注入其子类后，数据库则需存储其相应的加密后的密码（可使用该加密类中加密方法来手动获取加密后的密码） 直接使用Encoder,数据库则无需存储盐值。 1234@BeanPasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder();&#125; 💬 BCrypt为单向Hash加密,破解成本很高， BCrypt = BCrypt版本号 + salt盐 + Hash结果值其中Hash结果值 = Hash(明文密码,salt) 🔹 取消密码加密（已过时）在配置类中注入NoOpPasswordEncoder.getInstance() 1234@BeanPasswordEncoder passwordEncoder()&#123; return NoOpPasswordEncoder.getInstance();&#125; 3.4.设置角色继承关系 1234567@BeanRoleHierarchy roleHierarchy() &#123; RoleHierarchyImpl roleHierarchy = new RoleHierarchyImpl(); String hierarchy = \"ROLE_dba &gt; ROLE_admin \\n ROLE_admin &gt; ROLE_user\"; roleHierarchy.setHierarchy(hierarchy); return roleHierarchy;&#125; 4. HttpSecurity httpSecurity相关配置通过WebSecurityConfigurerAdapter的configure(HttpSecurity http)方法来配置。 4.1 控制请求路径权限（赋予角色） 4.1.1. 使用固定的资源路径权限信息 12345678910@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .antMatchers(\"/admin/**\").hasRole(\"admin\")// .antMatchers(\"user/**\").hasAnyRole(\"admin\",\"user\") .antMatchers(\"user/**\").access(\"hasAnyRole('admin','user')\") .anyRequest().authenticated() .and();&#125; 4.1.2. 动态更改 需要向容器注入两个类： 实现FilterInvocationSecurityMetadataSource接口的类 实现AccessDecisionManager接口的类 之后再将这两个类添加到HttpSecurity中。 FilterInvocationSecurityMetadataSource主要返回请求所需认证信息（角色）。AccessDecisionManager主要用来决定请求是否通过，通过返回，不通过则抛AccessDeniedException异常。 🔹 注入FilterInvocationSecurityMetadataSource 1234567891011121314151617181920212223242526272829303132333435363738@Componentpublic class MyFilter implements FilterInvocationSecurityMetadataSource &#123; //用于匹配url AntPathMatcher pathMatcher = new AntPathMatcher(); @Autowired MenuService menuService; /** * 根据请求地址设置所需要的角色 * 请求地址与数据库中无匹配项，则添加为需要登录 * @param o req + resp + chain * @return * @throws IllegalArgumentException */ @Override public Collection&lt;ConfigAttribute&gt; getAttributes(Object o) throws IllegalArgumentException &#123; //获取请求地址 String requestUrl = ((FilterInvocation) o).getRequestUrl(); //获取数据库中所有资源请求地址(含角色) List&lt;Menu&gt; allMenus = menuService.getAllMenus(); //查找当前请求路径与数据库中哪个资源请求匹配 // 匹配则返回其所需的认证信息（角色） for (Menu menu : allMenus) &#123; if (pathMatcher.match(menu.getPattern(), requestUrl)) &#123; List&lt;Role&gt; roles = menu.getRoles(); String[] rolesStr = new String[roles.size()]; for (int i = 0; i &lt; roles.size(); i++) &#123; rolesStr[i] = roles.get(i).getName(); &#125; return SecurityConfig.createList(rolesStr); &#125; &#125; // 无匹配项，默认返回 ROLE_login return SecurityConfig.createList(\"ROLE_login\"); &#125; ......&#125; 🔹 注入AccessDecisionManager 123456789101112131415161718192021222324252627282930313233343536373839404142@Componentpublic class MyAccessDecisionManager implements AccessDecisionManager &#123; /** * 根据当前角色信息，判断是否符合当前请求所需角色的要求 * @param authentication 当前登录用户的信息 * @param o 当前请求对象 * @param collection 当前请求对象所需的角色 对应着FilterInvocationSecurityMetadataSource * @throws AccessDeniedException * @throws InsufficientAuthenticationException */ @Override public void decide(Authentication authentication, Object o, Collection&lt;ConfigAttribute&gt; collection) throws AccessDeniedException, InsufficientAuthenticationException &#123; // 遍历所需角色信息 // 若当前角色在所需角色内，则返回，否则则抛异常 for (ConfigAttribute attribute : collection) &#123; if (\"ROLE_login\".equals(attribute.getAttribute())) &#123; if (authentication instanceof AnonymousAuthenticationToken) &#123; throw new AccessDeniedException(\"非法请求!\"); &#125; else &#123; return; &#125; &#125; Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities(); for (GrantedAuthority authority : authorities) &#123; if (authority.getAuthority().equals(attribute.getAttribute())) &#123; return; &#125; &#125; &#125; throw new AccessDeniedException(\"非法请求!\"); &#125; @Override public boolean supports(ConfigAttribute configAttribute) &#123; return true; &#125; @Override public boolean supports(Class&lt;?&gt; aClass) &#123; return true; &#125;&#125; 🔹 将自定义的两个类添加到HttpSecurity中 设置请求资源路径认证信息 判断请求内容是否符合认证信息 123456789101112131415161718@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .withObjectPostProcessor(new ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123; @Override public &lt;O extends FilterSecurityInterceptor&gt; O postProcess(O o) &#123; o.setAccessDecisionManager(myAccessDecisionManager); o.setSecurityMetadataSource(myFilter); return o; &#125; &#125;) .and() .formLogin() .permitAll() .and() .csrf().disable();&#125; 4.2. 配置登录表单 12345678910111213@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .formLogin() .loginProcessingUrl(\"/doLogin\") // .loginPage(\"/login\") //自定义登录页面 // .usernameParameter(\"uname\") //自定义参数名称 // .passwordParameter(\"password\") // // .successForwardUrl(\"/\") //登录成功后跳转到url .permitAll() ......&#125; 4.3. 登录成功\\失败后的操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() //登录成功后的操作 .successHandler((req, resp, authentication) -&gt; &#123; //authentication :登录成功的信息 PrintWriter writer = resp.getWriter(); resp.setContentType(\"application/json;charset=utf-8\"); HashMap&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"status\",200); map.put(\"message\",authentication.getPrincipal()); //向相应请求中写入信息 writer.write(new ObjectMapper().writeValueAsString(map)); writer.flush(); writer.close(); &#125;) // 登录失败后的操作 .failureHandler((req, resp, e) -&gt; &#123; PrintWriter writer = resp.getWriter(); resp.setContentType(\"application/json;charset=utf-8\"); HashMap&lt;String,Object&gt; map = new HashMap&lt;&gt;(10); map.put(\"status\",401); //判断失败的异常类型 if (e instanceof LockedException)&#123; map.put(\"message\",\"账号被锁定，登陆失败\"); &#125;else if (e instanceof BadCredentialsException)&#123; map.put(\"message\",\"账号或密码错误，登陆失败\"); &#125;else if (e instanceof DisabledException)&#123; map.put(\"message\",\"账号被禁用，登陆失败\"); &#125;else if (e instanceof AccountExpiredException)&#123; map.put(\"message\",\"账号过期，登陆失败\"); &#125;else if (e instanceof CredentialsExpiredException)&#123; map.put(\"message\",\"密码过期，登陆失败\"); &#125;else&#123; map.put(\"message\",\"登录失败\"); &#125; //向相应请求中写入信息 writer.write(new ObjectMapper().writeValueAsString(map)); writer.flush(); writer.close(); &#125;) ......&#125; 4.4. 退出登录 123456789101112131415161718192021@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() ... .logout() .logoutUrl(\"/logout\") //退出登录的请求url //退出成功后的操作 .logoutSuccessHandler((req, resp, authentication) -&gt; &#123; PrintWriter writer = resp.getWriter(); HashMap&lt;String,Object&gt; map = new HashMap&lt;&gt;(); resp.setContentType(\"application/json;charset=utf-8\"); map.put(\"status\",200); map.put(\"message\",\"注销成功\"); writer.write(new ObjectMapper().writeValueAsString(map)); writer.flush(); writer.close(); &#125;) ......&#125; 4.5. 关闭csrf 测试时使用。关闭csrf攻击的预防操作。 12345678@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() ... csrf().disable(); ......&#125; 5. 多个HttpSecurity 当多个HttpSecurity时，需在类上添加@order(value)注解来标明优先级。value值越低，优先级越高。 1234567891011121314151617181920212223242526272829303132333435@Configurationpublic class MuitlHttpSecurityConfig &#123; @Configuration @Order(1) static class AdminSecurity extends WebSecurityConfigurerAdapter&#123; @Override protected void configure(HttpSecurity http) throws Exception &#123;// http.authorizeRequests() 无效？// .antMatchers(\"/admin/**\").hasRole(\"admin\");// .antMatchers(\"user/**\").hasAnyRole(\"admin\",\"user\"); http.antMatcher(\"/admin/**\").authorizeRequests() .anyRequest().hasRole(\"admin\");// .and()// .antMatcher(\"user/**\").authorizeRequests()// .anyRequest().hasAnyRole(\"admin\",\"user\"); // 报错。why？？nested exception is java.lang.IllegalStateException: Can't configure anyRequest after itself &#125; &#125; @Configuration static class OtherSecurity extends WebSecurityConfigurerAdapter&#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .anyRequest().authenticated() .and() .formLogin().loginProcessingUrl(\"/doLogin\") .and() .csrf().disable(); &#125; &#125;&#125;","categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"个人笔记/Java","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/"},{"name":"SpringSecurity","slug":"个人笔记/Java/SpringSecurity","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/SpringSecurity/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jianxilin.github.io/tags/Java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://jianxilin.github.io/tags/SpringBoot/"},{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"https://jianxilin.github.io/tags/SpringSecurity/"}]},{"title":"validation的基本使用","slug":"validation的基本使用","date":"2020-05-27T13:26:39.000Z","updated":"2020-05-27T14:07:46.800Z","comments":true,"path":"2020/05/27/validation的基本使用/","link":"","permalink":"https://jianxilin.github.io/2020/05/27/validation%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"1、jar包引入 12345&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.0.9.Final&lt;/version&gt;&lt;/dependency&gt;","text":"1、jar包引入 12345&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.0.9.Final&lt;/version&gt;&lt;/dependency&gt; 2、校验注解 不仅仅只是可用在实体类中，也可用在（使用了@Validated ）controller、service的方法参数，service方法返回值。注解一般不会处理null情况。 👉原文链接 注解 使用 @NotNull 被注释的元素（任何元素）必须不为 null, 集合为空也是可以的。没啥实际意义 @NotEmpty 用来校验字符串、集合、map、数组不能为null或空 （字符串传入空格也不可以）（集合需至少包含一个元素） @NotBlank 只用来校验字符串不能为null，空格也是被允许的 。校验字符串推荐使用@NotEmpty @Size(max=, min=) 指定的字符串、集合、map、数组长度必须在指定的max和min内 允许元素为null，字符串允许为空格，==为null时，不生效。== @Length(min=,max=) 只用来校验字符串，长度必须在指定的max和min内 允许元素为null @Range(min=,max=) 用来校验数字或字符串的大小必须在指定的min和max内，字符串会转成数字进行比，如果不是数字校验不通过，允许元素为null @Min() 校验数字（包括integer short long int 等）的最小值，不支持小数即double和float，允许元素为null @Max() 校验数字（包括integer short long int 等）的最小值，不支持小数即double和float，允许元素为null @Pattern() 正则表达式匹配，可用来校验年月日格式，是否包含特殊字符（regexp = “^[a-zA-Z0-9\\u4e00-\\u9fa5 🔹 不常用 123456789@Null 被注释的元素必须为 null@AssertTrue 被注释的元素必须为 true@AssertFalse 被注释的元素必须为 false@DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值@DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值@Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内@Past 被注释的元素必须是一个过去的日期@Future 被注释的元素必须是一个将来的日期@Email 被注释的元素必须是电子邮箱地址 3、注解 3.1、@Validated 3.2、@RestController 3.3、@Valid 标记需验证的参数，可用于controller中方法的参数，也可在spring中， 可用于联级验证中的一对一、一对多。 A、一对一: 一个对象中包含另一个对象作为属性。 对这个对象属性添加该注解，这该对象中的验证也可使用。 B、一对多：一个对象中包含另一个对象容器作为属性。 注解可加在属性上，也可加载list泛型前。 3.4 @ExceptionHandler 在spring中，添加该注解的方法可对某异常进行捕获。 例如：MethodArgumentNotValidException e 4、在service中添加参数验收 4.1、实现方法 同controller。在类上添加@Validated，之后在需要进行参数验收 的参数前添加@Vaild。 4.2、注意事项 A、注解添加的位置。 @Vaild ：不能添加在接口实现类中，需放置在service的接口类中。 @Vaildated ：可添加在实现类或接口类中。 添加在接口类时，其对应的实现类也会进行参数验收。 B、需捕获的异常不同于controller。 并不是MethodArgumentNotValidException， 而是ConstraintViolationException(原生态的异常) 5、分组验收 无法使用于Service中 5.1、使用场景 对于不同功能，其对同一个实体的验证需求不同，则需要使用分组验收。 例如：添加新用户时，用户id需要为空值。而修改用户时，用户id则不能为空值。 5.2、实现 1️⃣ 设置分组 利用参数验证注解中的groups参数。 未设置分组的参数属于默认分组 2️⃣ 指定分组 由于@Valid无法实现该功能，故需使用@Validated来标记需参数验收的参数。 利用@Validated的value来指定分组。 6、自定义注解 6.1 实现 1️⃣ 实现注解（eg：MultipleOfThree） 2️⃣ 实现业务处理类（实现 ConstrainValidator接口） 7、校验List中的参数 7.1、获取validtor 1️⃣ 获取validtor 2️⃣ 从SpringBoot中获取(创建工具类获取，不直接注入到使用类中，因为Validtor非单例) 7.2、创建自定义注解 7.3、创建注解处理类 1️⃣ 注解处理类 2️⃣ 自定义异常类(由于处理类默认返回boolean,需改成抛出异常) 3️⃣ 捕获该异常类 4️⃣ 使用注解 8、参数间的逻辑校验 8.1、实现思路（分组动态化） 🔹 利用hibernate.validator 中提供的SequenceProvider——可进行分组的添加 &emsp;&emsp;通过SequenceProvider 来根据被校验的对象的属性变化，对添加分组。 8.2、实现方法 1️⃣ 创建SequenceProvider，在添加默认分组后，进行逻辑判断，以添加不同分组。 2️⃣ 使用SequenceProvider，在实体类中使用@GroupSequenceProvider","categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"个人笔记/Java","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/"},{"name":"validation","slug":"个人笔记/Java/validation","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/validation/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jianxilin.github.io/tags/Java/"},{"name":"vaildation","slug":"vaildation","permalink":"https://jianxilin.github.io/tags/vaildation/"},{"name":"数据校验","slug":"数据校验","permalink":"https://jianxilin.github.io/tags/%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/"}]},{"title":"axios的基本使用","slug":"axios的基本使用","date":"2020-05-27T12:58:49.000Z","updated":"2020-05-27T14:07:46.027Z","comments":true,"path":"2020/05/27/axios的基本使用/","link":"","permalink":"https://jianxilin.github.io/2020/05/27/axios%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"1. 简介 基于promise的对ajax的一个封装ajax适合于mvcpromise则适用于mvvm","text":"1. 简介 基于promise的对ajax的一个封装ajax适合于mvcpromise则适用于mvvm 2.使用 2.1 基本写法 123456789101112131415&lt;script src=\"https:unpkg.com.axios/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;script&gt; axios(&#123; url:\"url\", method:'get'|'post', //get为默认方式 param:&#123;--&#125; // param:&#123;name:小明&#125; //用过于get方法传参 同添加到url中 //post使用该参数，同样也是将参数添加到url中 data:&#123;--&#125; //用于post方法传参数 &#125;).then(res=&gt;&#123; console.log(res) &#125;).catch(err=&gt;&#123; console.log(err) &#125;)&lt;/script&gt; post传参注意点:带参请求默认为使用 application/json。1.param 可实现传参，但参数添加到url中2.使用axios.post(‘url’,’data’)3.使用data参数，后端对数据进行处理。如Springboot中使用@requestBody,将json转为java对象。 2.2 简写 2.2.1 get 1234567891011&lt;script src=\"https:unpkg.com.axios/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;script&gt; axios.get(&#123; \"url\", &#123;params:&#123;--&#125;&#125; // &#123;params:&#123;name:小明&#125;&#125; &#125;).then(res=&gt;&#123; console.log(res) &#125;).catch(err=&gt;&#123; console.log(err) &#125;)&lt;/script&gt; 2.2.2 post 123456789101112&lt;script src=\"https:unpkg.com.axios/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;script&gt; axios.post(&#123; \"url\", \"data\", // \"name=小明&amp;age=20\" &#123;data&#125; // &#123;data:&#123;name:'小明'&#125;&#125; &#125;).then(res=&gt;&#123; console.log(res) &#125;).catch(err=&gt;&#123; console.log(err) &#125;)&lt;/script&gt; 3.发送多个请求 3.1 使用res数组获取多个请求结果 1234567891011&lt;script src=\"https:unpkg.com.axios/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;script&gt; axios.all(&#123; axios.get(--), axios.get(--) &#125;).then(res=&gt;&#123; console.log(res[0]+res[1]) &#125;).catch(err=&gt;&#123; console.log(err) &#125;)&lt;/script&gt; 3.2 使用axios.spread()获取多个请求结果 12345678910111213&lt;script src=\"https:unpkg.com.axios/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;script&gt; axios.all(&#123; axios.get(--), axios.get(--) &#125;).then( axios.spread((res1,res2)=&gt;&#123; console.log(res1+res2) &#125;) &#125;).catch(err=&gt;&#123; console.log(err) &#125;)&lt;/script&gt; 4. 全局配置 可将公共数据提取出来，get、post请求内容中则无需再写这些公共内容。比如提取url的公共部分、提取超时参数。 1234567891011&lt;script src=\"https:unpkg.com.axios/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;script&gt; axios.defaults.baseurl=\"http://-:8080/person\", axios.defaults.timeout=3000, axios.get('getall').then(res=&gt;&#123; // == http://-:8080/person/getall console.log(res) &#125;) axios.post('update').then(res=&gt;&#123; // == http://-:8080/person/update console.log(res) &#125;)&lt;/script&gt; 5. axios实例 12345678910111213&lt;script src=\"https:unpkg.com.axios/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;script&gt; // 定义 let newVar = axios.create(&#123; baseURL:'url', timeout:5000 &#125;); // 使用 newVar(&#123; url:'getAll' &#125;)&lt;/script&gt; 6. 拦截器 12345678&lt;script src=\"https:unpkg.com.axios/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;script&gt; axios.interceptors.request.use(config=&gt;&#123; // 进入前 &#125;,err=&gt;&#123; // 发生错误 &#125;);&lt;/script&gt; 7. 在vue中进行模块封装 基于 import-export 来进行封装，类似函数封装 vue中安装axios: npm install axios –save 7.1 无返回值 🔹 封装内容 (位置 : /network/request/request.js): 12345678910import axios form 'axios'export function request(url,success,fail)&#123; axios(&#123; url:url &#125;).then(res=&gt;&#123; success(res) &#125;).catch(err=&gt;&#123; fail(err) &#125;)&#125; 🔹 调用: 12import &#123;request&#125; form './network/request/request.js'request(url,res=&gt;&#123;&#125;,err=&gt;&#123;&#125;) 7.2 返回Promise对象 Promise中需声明、创建实例.Promise为ES6中的语法点，其内容代指即将发生的事件 🔹 封装内容： 12345678910111213141516import axios form 'axios'export function request(config)&#123; return new Promise((resolve,reject)=&gt;&#123; //声明实例 let newVar = axios.create(&#123; baseURL:\"url\", timeout:5000 &#125;); //创建实例 newVar(config).then(res=&gt;&#123; resolve(res) //res将作为参数传给回调函数 &#125;).catch(err=&gt;&#123; reject(err) &#125;) &#125;)&#125; 🔹 调用 12import &#123;request&#125; form './network/request/request.js'request(&#123;url:'url'&#125;).then(res=&gt;&#123;&#125;).catch(err=&gt;&#123;&#125;) 7.3 返回实例 方法内声明实例。本质同返回Promise对象 🔹 封装内容： 12345678910import axios form 'axios'export function request(config)&#123; //声明实例 let newVar = axios.create(&#123; baseURL:\"url\", timeout:5000 &#125;); //创建实例并返回 return newVar(config);&#125; 🔹 调用 12import &#123;request&#125; form './network/request/request.js'request(&#123;url:'url'&#125;).then(res=&gt;&#123;&#125;).catch(err=&gt;&#123;&#125;)","categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"name":"前端","slug":"个人笔记/前端","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF/"},{"name":"axios","slug":"个人笔记/前端/axios","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF/axios/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://jianxilin.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"axios","slug":"axios","permalink":"https://jianxilin.github.io/tags/axios/"}]},{"title":"[总结]Java容器","slug":"总结-Java容器","date":"2020-05-21T07:42:36.000Z","updated":"2020-05-21T07:45:29.851Z","comments":true,"path":"2020/05/21/总结-Java容器/","link":"","permalink":"https://jianxilin.github.io/2020/05/21/%E6%80%BB%E7%BB%93-Java%E5%AE%B9%E5%99%A8/","excerpt":"1. List、Map、Set 🔹 List: 用于排序。元素有序、可重复。&emsp;&emsp;&emsp;&emsp;实现：Object数组 | 双向链表🔹 Map：用于搜索。存储键值对。key不可重复。&emsp;&emsp;&emsp;&emsp;实现：数组+链表（JDK1.8前），数组+链表+红黑树（JDK1.8~）🔹 Set：无重复（去重）。不可重复。&emsp;&emsp;&emsp;&emsp;实现：使用Map中的Key","text":"1. List、Map、Set 🔹 List: 用于排序。元素有序、可重复。&emsp;&emsp;&emsp;&emsp;实现：Object数组 | 双向链表🔹 Map：用于搜索。存储键值对。key不可重复。&emsp;&emsp;&emsp;&emsp;实现：数组+链表（JDK1.8前），数组+链表+红黑树（JDK1.8~）🔹 Set：无重复（去重）。不可重复。&emsp;&emsp;&emsp;&emsp;实现：使用Map中的Key RandomAccess：标记型接口。表示可随机访问元素（可快速访问）。 2. List 2.1 ArrayList、LinkedList 区别 2.1.1 底层实现 🔹 ArrayList：数组🔹 LinkedList：双向链表（1.7~），1.7之前是循环链表。 循环链表相比双向链表的缺点：&emsp;1️⃣ 初始化时，需先创建一个空节点作为头节点，以避免需要多次校验头节点是否为null。&emsp;2️⃣ 头尾部节点不够清晰，且在头尾部分进行增删时，需处理头尾部两个节点的指针。 2.1.2 增删元素 🔹 ArrayList：默认时，复杂度O(1)。指定位置时，复杂度O(n-i)。 增删某元素将对后续元素位置产生影响。不指定位置则默认增加到尾部。🔹 LinkedList: 复杂度O(1)。 2.1.3 查找元素 🔹 ArrayList：可快速查询🔹 LinkedList：需遍历查询 2.1.4 线程安全性 🔹 两者都是非线程安全的 2.1.5 空间占用 🔹 ArrayList：需要预留容量空间🔹 LinkedList：每个节点需存储前继和后续节点的指针 2.1.6 扩容 🔹 ArrayList：+50%,初始值10🔹 LinkedList：且无需扩容,无初始值 2.2 ArrayList、Vector 区别 2.2.1 线程安全性 🔹 ArrayList：非线程安全🔹 Vector：线程安全 2.2.2 效率 🔹 ArrayList：效率更高🔹 Vector：效率低 Vector每个方法都添加了同步，即Synchronized。导致效率低。 2.2.3 扩容 🔹 ArrayList：增加 50%，初始容量10🔹 Vector：增加 100%，初始容量10 12//ArrayList的grow中的增加的值int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); 3. Map and Set 3.1 HashMap 与 HashTable(不使用) 3.1.1 底层实现 🔹 HashMap: 数组+红黑树+链表(1.8~),1.8前是数组+链表&emsp; jdk1.8，为了解决哈希冲突所带来的问题，当链表长度大于阈值(默认为8)，且当前长度不小于64，则将链表转为红黑树。若长度小于64，则是进行扩容。🔹 HashTable: 数组+链表 3.1.2 线程安全性 🔹 HashMap：线程不安全。若需线程安全可使用ConcurrentHashMap🔹 HashTable：线程安全。几乎大部分方法都加了同步 3.1.3 效率 🔹 HashMap：效率高🔹 HashTable：效率低 3.1.4 扩容 🔹 HashMap:增加一倍。初始值为16。扩容因子默认为0.75&emsp;若指定大小时，长度将为比该值稍大或等于的2的幂次方。这是由于hash%length==hash&amp;(2^n-1)，且&amp;的效率高于%。&emsp;eg: 指定值为50, 50 &lt; 2^6. 故容量为2^6=16 🔹 HashTable:增加一倍,再+1.初始值为11 3.1.5 null值的处理 🔹 HashMap:key和value都支持null值，key仍不可重复🔹 HashTable:抛NullPointerException 3.2 HashMap 与 HashSet 3.2.1 底层实现 HashSet底层与HashMap一致，其内部调用了HashMap的方法。 1234567891011//HashSet 中的代码：其中的方法实现是通过HashMap代理来实现private transient HashMap&lt;E,Object&gt; map;private static final Object PRESENT = new Object();public int size() &#123; return map.size();&#125;public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; 3.2.2 对Hashcode的计算 🔹 HashMap：根据key和value进行运算🔹 HashSet：没有重写HashCode方法，value值以空对象代替。 123456789101112131415161718192021//该节点类为HashMap中内部类static class Node&lt;K, V&gt; implements Entry&lt;K, V&gt; &#123; //key和value的地址进行异或运算（不同则1，相同则0） public final int hashCode() &#123; return Objects.hashCode(this.key) ^ Objects.hashCode(this.value); &#125; public final boolean equals(Object var1) &#123; if (var1 == this) &#123; return true; &#125; else &#123; if (var1 instanceof Entry) &#123; Entry var2 = (Entry)var1; if (Objects.equals(this.key, var2.getKey()) &amp;&amp; Objects.equals(this.value, var2.getValue())) &#123; return true; &#125; &#125; return false; &#125; &#125;&#125; 📁内容补充：hashcode() 与 equals() 🔹 Object中的hashcode()，是关于其该对象实例的内存地址。🔹 Map中，hashcode 相同，equals不一定相等，表示在同一个散列数据结构（链表）。equal相等，hashcode一定相等。🔹 由于hashcode存在冲突，故需要使用equals进行判断。 3.3 ConcurrentHashMap 与 HashTable 两者都是线程安全。HashTable几乎所有方法都添加了同步，效率低。JDK1.7的ConcurrentHashMap则是来取代HashTable。 3.3.1 底层实现 🔹 ConcurrentHashMap：同HashMap🔹 HashTable：数组+链表 3.3.2 线程安全的策略 🔹 ConcurrentHashMap：使用“分段式锁”。&emsp;每一段数据分别加锁。而且加的锁是ReentrantLock可重入锁。&emsp;👉图片来源 🔹 HashTable：大部分方法添加了同步。如put/get方法添加了Synchronzed。&emsp;效率很低，近似整个容器对象添加了锁。&emsp;👉图片来源","categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"个人笔记/Java","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/"},{"name":"基础","slug":"个人笔记/Java/基础","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/%E5%9F%BA%E7%A1%80/"},{"name":"容器","slug":"个人笔记/Java/基础/容器","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/%E5%9F%BA%E7%A1%80/%E5%AE%B9%E5%99%A8/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jianxilin.github.io/tags/Java/"},{"name":"Java容器","slug":"Java容器","permalink":"https://jianxilin.github.io/tags/Java%E5%AE%B9%E5%99%A8/"}]},{"title":"[总结]Git的基本使用","slug":"总结-Git的基本使用","date":"2020-05-13T03:48:49.000Z","updated":"2020-06-01T13:25:00.301Z","comments":true,"path":"2020/05/13/总结-Git的基本使用/","link":"","permalink":"https://jianxilin.github.io/2020/05/13/%E6%80%BB%E7%BB%93-Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"Git作为一个版本控制的工具,在我们学习过程中是必不可少的。不仅是Git仓库GitHub、Gitee，还是在编辑器VSCode，Git在管理文件、控制文件版本、回退文件、多人协作、并发开发等有着重要的地位。以下将对Git的基本使用继续总结、记录。","text":"Git作为一个版本控制的工具,在我们学习过程中是必不可少的。不仅是Git仓库GitHub、Gitee，还是在编辑器VSCode，Git在管理文件、控制文件版本、回退文件、多人协作、并发开发等有着重要的地位。以下将对Git的基本使用继续总结、记录。 1. Git与SVN的简单区分 🔹 实现方式上&emsp;SVN : 集中版本控制。SVN所控制的所有版本内容存储在单一服务器上，本地用户在未联网的情况下，只能看到所同步的版本内容。&emsp;Git : 分布式版本控制。不同于SVN，本地的每个本地用户都能获取到所有版本内容，且Commit操作是在用户本地进，之后再push到远端仓库。&emsp;Git相比SVN，空间成本增加了，且安全性也有所下降，但也减少了数据损失而无法恢复的风险。 🔹 克隆多分支项目&emsp;SVN克隆所有分支的内容&emsp;Git克隆master分支,其它分支只获取相关元素，节省了时间。 2. Git的基本使用 2.1 配置信息 🔹 获取配置信息： 123456// 获取全部配置信息git config -l// 获取系统级别配置信息，对应 \\git主目录\\etc\\gitconfiggit config --system -l// 获取用户(全局)级别的配置信息，对应 \\user\\Administrator\\.gitconfiggit config --global -l 🔹 配置全局的用户信息 12git config --global user.name \"用户名\"git config --global user.email 邮箱 2.2 操作仓库内容 🔹 初始化本地仓库 1git init 🔹 添加到缓存并提交到本地仓库 12git add . git commit -m \"注释\\提交的说明信息\" 🔹 提交到远程仓库 1git push 地址 master 🔹 克隆远程仓库 \\ 获取远程代码 12git clone 地址 分支(eg:master)git pull 地址 分支(eg:master) 🔹 查看本地文件状态 1git status 3.HEAD HEAD 指当前分支的最近一次提交head 指commit对象 head 包含 HEAD 🔹 占位符 ~ 与 ^ ~ ： 表示祖先commit&emsp;&emsp;eg : HEAD~ = HEAD~1 = 前一代commit（父辈）&emsp;&emsp;&emsp;HEAD~~ = HEAD~2 = 前两代commit（爷爷辈）^ : 单个父辈时，与 ~ 基本一致。&emsp;&emsp;多个父辈时，^ = ^1 = 第一个父辈 🔹 案例 1234567891011121314151617181920G H I J \\ / \\ / D E F \\ | / \\ \\ | / | \\|/ | B C \\ / \\ / AA = = A^0B = A^ = A^1 = A~1C = A^2 = A^2D = A^^ = A^1^1 = A~2E = B^2 = A^^2F = B^3 = A^^3G = A^^^ = A^1^1^1 = A~3H = D^2 = B^^2 = A^^^2 = A~2^2I = F^ = B^3^ = A^^3^J = F^2 = B^3^2 = A^^3^2 👉此内容参考来源 4. 信息查看 🔹 获取本地文件状态 1git status 🔹 获取commit历史信息 12git loggit log --oneline 🔹 查看当前索引(暂存区) 1git ls-files -s 🔹 显示了 HEAD 快照实际的目录列表 1git cat-file -p HEAD 🔹 查看HEAD的当前指向 1cat .git/HEAD 🔹 查看HEAD各个祖先 1git rev-parse HEAD~ //前一个祖先(父辈) 5. 撤销操作 🔹 git checkout [不写|HEAD] &lt;file&gt; //旧版 🔹 git restore [不写|–staged] &lt;file&gt; //新版 🔹 git reset [–hard|soft|mixed(默认)|merge|keep] [commit|HEAD](1) –soft : 回退到暂存区状态(2) –mixed : 回退到本地状态（本地修改的内容存在）(3) –hard : 回退到某次提交，清除所有历史状态，包括本地文件内容。 🔹 git revert HEAD^ 重新提交，保留历史记录 git reset不保留历史记录 🔹 重写最后一次commit 1git commit --amend -m 6. 冲突解决 🔹 提交时，发生冲突 执行git pull，发生冲突后，git会将两个版本的内容合并在一起。解决：先git status，查找发生冲突的文件，自行修改冲突内容后再提交，pull 🔹 回退commit，发生冲突 执行revert HEAD^，发生冲突。解决：同样查看冲突、修改冲突后，执行git revert –continue。 7. Git的分支处理 🔹 常用命令 12345678910111213141516171819202122232425262728# 列出所有本地分支git branch# 列出所有远程分支git branch -r# 新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支git checkout -b [branch]# 将分支推到远端git push 地址 dev(分支名):dev(分支名)# 切换分支git checkout [branch]# 合并指定分支到当前分支$ git merge [branch]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 👉此内容来源 参考文章：狂神说 聊Git📘CSDN 奋飛 Git Pro深入浅出（二）📘","categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"name":"工具","slug":"个人笔记/工具","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7/"},{"name":"版本控制","slug":"个人笔记/工具/版本控制","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"Git","slug":"个人笔记/工具/版本控制/Git","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/"}],"tags":[{"name":"版本控制","slug":"版本控制","permalink":"https://jianxilin.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"Git","slug":"Git","permalink":"https://jianxilin.github.io/tags/Git/"}]},{"title":"[总结]CSS样式失效的原因","slug":"总结-CSS样式失效的原因","date":"2020-05-11T06:49:33.000Z","updated":"2020-05-11T08:50:02.318Z","comments":true,"path":"2020/05/11/总结-CSS样式失效的原因/","link":"","permalink":"https://jianxilin.github.io/2020/05/11/%E6%80%BB%E7%BB%93-CSS%E6%A0%B7%E5%BC%8F%E5%A4%B1%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0/","excerpt":"CSS样式生效，需要正确的语法，并且其样式内容不被覆盖。以下先总结三点原因（后续再补充）：🔹 错误使用单行注释🔹 CSS选择器优先级较低🔹 Chrome浏览器存在CSS文件缓存","text":"CSS样式生效，需要正确的语法，并且其样式内容不被覆盖。以下先总结三点原因（后续再补充）：🔹 错误使用单行注释🔹 CSS选择器优先级较低🔹 Chrome浏览器存在CSS文件缓存 1. 在外部CSS中不能使用单行注释 在CSS选择器上使用单行注释，将导致该注释下的这个CSS选择器里面的内容失效。如下代码所示,“.post-readmore__link{}”将失效,“.post-readmore__link:hover{}”有效，不会受到影响。 1234567//readmore button （第一个CSS选择器无效）.post-readmore__link&#123; background-color: #27ae60;&#125;.post-readmore__link:hover&#123; background-color: #1f7f47;&#125; 而单行注释添加在CSS样式内，该CSS仍有效 123.post-readmore__link&#123; background-color: #27ae60; //green （有效）&#125; 若需要使用注释，可使用多行注释。如下： 1234/* readmore button */.post-readmore__link&#123; background-color: #27ae60; //green （有效）&#125; 2. CSS选择器优先级低于原有的CSS选择器 2.1. 当多个CSS选择器选择目标相同时 🔹 级别相同，后加载的CSS选择器覆盖前CSS选择器中相同的样式。🔹 级别不同，高级别CSS选择器覆盖低级别CSS选择器中相同的样式。 2.2. 级别判断 🔹 内嵌式CSS级别高于外部CSS，可视为最高级别。 🔹 #ID &gt; .Class、属性选择器([type=”button”])和伪类(:hover) &gt; 标签类型和伪元素(::after)级别计算案例：图片内容来源：MDN Web Docs 🔹 使用!important覆盖任何样式声明 123.post-readmore__link&#123; background-color: #27ae60 !important;&#125; 对于都添加！important的样式，则再由其选择器优先级来判断。 3.chrome浏览器存在缓存 🔹 原因:&emsp;&emsp;chrome浏览器为了提高加载效率，缓存了JS、CSS文件，故修改后的文件无法立即生效。 🔹 解决方法：方式一：来回切换开启缓存来重置缓存内容（不一定有效）。&emsp;&emsp;F12打开开发者工具，进入Network，在Disable cache前打勾✔，刷新页面。再把Disable cache关闭，取消✔，再次刷新页面。 方式二：来回切换开启缓存来重置缓存内容&emsp;&emsp;F12打开开发者工具，然后在浏览器的刷新按钮右击，选择“清空缓存并硬性重新加载”","categories":[{"name":"踩坑记录","slug":"踩坑记录","permalink":"https://jianxilin.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"},{"name":"前端","slug":"踩坑记录/前端","permalink":"https://jianxilin.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"踩坑记录/前端/CSS","permalink":"https://jianxilin.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://jianxilin.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"CSS","permalink":"https://jianxilin.github.io/tags/CSS/"}]},{"title":"个人博客[2]——美化","slug":"个人博客-2-——美化","date":"2020-05-11T06:46:50.000Z","updated":"2020-05-11T06:56:49.141Z","comments":true,"path":"2020/05/11/个人博客-2-——美化/","link":"","permalink":"https://jianxilin.github.io/2020/05/11/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-2-%E2%80%94%E2%80%94%E7%BE%8E%E5%8C%96/","excerpt":"环境要求：node.js 和 npm基于 Hexo博客框架基于 Hexo主题stun 美化内容以下：🔹 主题设置🔹 博客主题样式自定义🔹 博客文章样式自定义","text":"环境要求：node.js 和 npm基于 Hexo博客框架基于 Hexo主题stun 美化内容以下：🔹 主题设置🔹 博客主题样式自定义🔹 博客文章样式自定义 效果图： 👉Hexo官方地址 👉Hexo-theme-stun官方地址 1. 修改主题 1.1. 下载主题(stun) git clone https://github.com/liuyib/hexo-theme-stun.git themes/stun 1.2. 配置主题 修改_config.yml 123#Extensions...theme: yilia 1.3. Hexo重设与发布 清除 hexo clean 创建 hexo g 启动 hexo s 推到远端 hexo d 2. 基本样式修改 主题的相关设置详见官方文档📗 可修改Hexo主路径下的_config.yml,将生效于所有主题。也可修改hexo/theme/stun下的_config.xml,将只生效于stun主题。 2.1. 修改博客图标等图片 🔹 方式一：覆盖原图像 在Hexo主路径下的\\themes\\stun\\source\\images\\icons中，使用相同大小的图片覆盖。之后查看stun下的_config.xml是否开启对应的功能。 🔹 方式二：自定义路径 在_config.xml相应的配置下，设置图片路径为自定义图片路径（Hexo下的路径、图床上的路径） 2.2. 修改网页样式 🔹 修改文章样式 将CSS样式添加到stun主题的路径下的\\source\\css_custom\\index.styl文件内即可。内容如下： 1234567891011121314151617// Custom styles by yourself.// You should always modify the style here, not in the source code.// Otherwise, when the theme is updated, the code you modified will be overwritten.body &#123; // modify your style here // eg: background-color: blue; h1 &#123; text-align: center; &#125; h1, h2&#123; color: #4CAF50; &#125; ...&#125; 🔹 修改博客样式 （1）在stun主题的路径下的\\source\\css创建文件夹，自定义名称，名称前需带”_”，例如：_myCss。在该创建的文件夹下放置个人的CSS文件。（2）配置CSS文件。在stun\\source\\css\\index.styl文件内添加以下内容：@import ‘个人的CSS文件全路径’如下： 12345678910111213141516// Variables Layer// --------------------------------------------------@import './_variables/index.styl';// Mixins Layer// --------------------------------------------------@import './_mixins/index.styl';// Common Layer// --------------------------------------------------@import './_common/index.styl';// Custom Layer// --------------------------------------------------@import './_custom/index.styl';// MyCSS// --------------------------------------------------@import './_myCss/myCss.css';","categories":[{"name":"个人博客","slug":"个人博客","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"个人博客","slug":"个人博客","permalink":"https://jianxilin.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}]},{"title":"个人博客[3]——写作","slug":"个人博客-3-——写作","date":"2020-05-11T06:44:24.000Z","updated":"2020-05-11T06:55:24.757Z","comments":true,"path":"2020/05/11/个人博客-3-——写作/","link":"","permalink":"https://jianxilin.github.io/2020/05/11/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-3-%E2%80%94%E2%80%94%E5%86%99%E4%BD%9C/","excerpt":"环境要求：node.js 和 npm基于 Hexo博客框架基于 Hexo主题stun 本文内容包含：🔹 创建、修改、删除文章🔹 创建分类、标签页面🔹 在stun主题内开启分页和标签页面","text":"环境要求：node.js 和 npm基于 Hexo博客框架基于 Hexo主题stun 本文内容包含：🔹 创建、修改、删除文章🔹 创建分类、标签页面🔹 在stun主题内开启分页和标签页面 1. 创建 具体操作见官方文档📗 1.1. 创建文章 12hexo n \"文章名称\"hexo c &amp; hexo g 1.2. 创建分类、标签页面（即创建页面） 🔹 创建分类页面 在Hexo主路径下，执行以下命令 1hexo new page categories 在文章编写时，在文章顶部的Front-matter添加分类信息： 1234categories： - 分类名称 - 下一级分类名称 - [同级分类名称...] 🔹 创建标签页面 与创建分页页面相同，将categories改为tags即可。不同的是，Front-matter中的tags没有分级。 例子： 12345678910---title: '个人博客[1]——搭建'date: 2020-05-10 17:39:21tags: 个人博客categories: - 个人博客photos: - url--- 🔹 在stun主题内开启分页和标签页面 在stun主路径下的_config.yml配置文件的menu节点下添加页面配置信息，如下 1234567menu: home: / || fas fa-home archives: /archives/ || fas fa-folder-open categories: /categories/ || fas fa-layer-group tags: /tags/ || fas fa-tags # You can add a secondary menu like follow. # xxx1: javascript:; || fa(s|r|l|d|b) fa-xxx 效果图： 2.修改 2.1. 修改文章名称 &emsp;&emsp;Hexo未提供修改文件名称的命令。 🔹 解决方法： &emsp;&emsp;最简单的方式就是重新创建该文章，将要修改文章迁移过去。单独修改文章名称和修改文章内的Title标签是无效的。&emsp;&emsp;也可使用hexo-console-renamer插件，后续使用后再来补充。 2.2 删除文章 &emsp;&emsp;同样的，Hexo未提供删除文章的命令。 🔹 解决方法： &emsp;&emsp;在Hexo主路径下的\\source_posts文件夹内，手动删除文章文件，之后再重新创建博客内容，即运行以下命令 1hexo c &amp; hexo g","categories":[{"name":"个人博客","slug":"个人博客","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"个人博客","slug":"个人博客","permalink":"https://jianxilin.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}]},{"title":"个人博客[1]——搭建","slug":"个人博客-1-——搭建","date":"2020-05-10T09:39:21.000Z","updated":"2020-05-11T04:32:41.744Z","comments":true,"path":"2020/05/10/个人博客-1-——搭建/","link":"","permalink":"https://jianxilin.github.io/2020/05/10/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-1-%E2%80%94%E2%80%94%E6%90%AD%E5%BB%BA/","excerpt":"环境要求：node.js 和 npm基于 Hexo博客框架 👉Hexo官方地址","text":"环境要求：node.js 和 npm基于 Hexo博客框架 👉Hexo官方地址 1. 配置环境 安装node.js和npm修改npm的镜像为阿里镜像，即按照cnpm 安装cnpm cmd命令： &emsp;&emsp;npm install -g cnpm –registry=https://registry.npm.taobao.org 安装测试： &emsp;&emsp;cnpm -v 2. 安装Hexo框架 2.1. 安装：cnpm install -g hero-cli 2.2. 验证安装：hexo -v 3. 初始化Hexo博客 3.1. 初始化hexo项目：hexo init 3.2. 启动项目：hexo s 4. 添加第一篇文章 👉Hexo官方:写作 创建新文章：hexo n 文件名 清理：hexo clean 生成文章：hexo g 重启：hexo s 5. 部署到GitHub上 5.1. 创建git仓库,名称为 “git账号名.github.io”5.2. 安装github部署插件。 在本地博客路径下，运行 cnpm install –save hexo-deployer-git 5.3. 添加仓库信息 修改_config.yml。 在#deployment节点下，内容如下： ==冒号后需 + 空格== 12345#deploymentdeploy: type: git repo: 仓库地址 branch: master5.4. 部署到远端 hexo d","categories":[{"name":"个人博客","slug":"个人博客","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"个人博客","slug":"个人博客","permalink":"https://jianxilin.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}]}],"categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"name":"RESTful","slug":"个人笔记/RESTful","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/RESTful/"},{"name":"Java","slug":"个人笔记/Java","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/"},{"name":"SpringCache","slug":"个人笔记/Java/SpringCache","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/SpringCache/"},{"name":"SpringSecurity","slug":"个人笔记/Java/SpringSecurity","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/SpringSecurity/"},{"name":"validation","slug":"个人笔记/Java/validation","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/validation/"},{"name":"前端","slug":"个人笔记/前端","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF/"},{"name":"axios","slug":"个人笔记/前端/axios","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF/axios/"},{"name":"基础","slug":"个人笔记/Java/基础","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/%E5%9F%BA%E7%A1%80/"},{"name":"容器","slug":"个人笔记/Java/基础/容器","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/%E5%9F%BA%E7%A1%80/%E5%AE%B9%E5%99%A8/"},{"name":"工具","slug":"个人笔记/工具","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7/"},{"name":"版本控制","slug":"个人笔记/工具/版本控制","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"Git","slug":"个人笔记/工具/版本控制/Git","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/"},{"name":"踩坑记录","slug":"踩坑记录","permalink":"https://jianxilin.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"},{"name":"前端","slug":"踩坑记录/前端","permalink":"https://jianxilin.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"踩坑记录/前端/CSS","permalink":"https://jianxilin.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/%E5%89%8D%E7%AB%AF/CSS/"},{"name":"个人博客","slug":"个人博客","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"RESTful","slug":"RESTful","permalink":"https://jianxilin.github.io/tags/RESTful/"},{"name":"Java","slug":"Java","permalink":"https://jianxilin.github.io/tags/Java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://jianxilin.github.io/tags/SpringBoot/"},{"name":"Redis","slug":"Redis","permalink":"https://jianxilin.github.io/tags/Redis/"},{"name":"SpringCache","slug":"SpringCache","permalink":"https://jianxilin.github.io/tags/SpringCache/"},{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"https://jianxilin.github.io/tags/SpringSecurity/"},{"name":"vaildation","slug":"vaildation","permalink":"https://jianxilin.github.io/tags/vaildation/"},{"name":"数据校验","slug":"数据校验","permalink":"https://jianxilin.github.io/tags/%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/"},{"name":"前端","slug":"前端","permalink":"https://jianxilin.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"axios","slug":"axios","permalink":"https://jianxilin.github.io/tags/axios/"},{"name":"Java容器","slug":"Java容器","permalink":"https://jianxilin.github.io/tags/Java%E5%AE%B9%E5%99%A8/"},{"name":"版本控制","slug":"版本控制","permalink":"https://jianxilin.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"Git","slug":"Git","permalink":"https://jianxilin.github.io/tags/Git/"},{"name":"CSS","slug":"CSS","permalink":"https://jianxilin.github.io/tags/CSS/"},{"name":"个人博客","slug":"个人博客","permalink":"https://jianxilin.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}]}