{"meta":{"title":"Jianxi's Blog","subtitle":"Learn to code and share","description":"","author":"JianxiLin","url":"https://jianxilin.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-05-10T16:01:52.000Z","updated":"2020-05-10T16:06:36.161Z","comments":true,"path":"categories/index.html","permalink":"https://jianxilin.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-10T16:02:27.000Z","updated":"2020-05-10T16:06:09.613Z","comments":true,"path":"tags/index.html","permalink":"https://jianxilin.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"[总结]Java容器","slug":"总结-Java容器","date":"2020-05-21T07:42:36.000Z","updated":"2020-05-21T07:45:29.851Z","comments":true,"path":"2020/05/21/总结-Java容器/","link":"","permalink":"https://jianxilin.github.io/2020/05/21/%E6%80%BB%E7%BB%93-Java%E5%AE%B9%E5%99%A8/","excerpt":"1. List、Map、Set 🔹 List: 用于排序。元素有序、可重复。&emsp;&emsp;&emsp;&emsp;实现：Object数组 | 双向链表🔹 Map：用于搜索。存储键值对。key不可重复。&emsp;&emsp;&emsp;&emsp;实现：数组+链表（JDK1.8前），数组+链表+红黑树（JDK1.8~）🔹 Set：无重复（去重）。不可重复。&emsp;&emsp;&emsp;&emsp;实现：使用Map中的Key","text":"1. List、Map、Set 🔹 List: 用于排序。元素有序、可重复。&emsp;&emsp;&emsp;&emsp;实现：Object数组 | 双向链表🔹 Map：用于搜索。存储键值对。key不可重复。&emsp;&emsp;&emsp;&emsp;实现：数组+链表（JDK1.8前），数组+链表+红黑树（JDK1.8~）🔹 Set：无重复（去重）。不可重复。&emsp;&emsp;&emsp;&emsp;实现：使用Map中的Key RandomAccess：标记型接口。表示可随机访问元素（可快速访问）。 2. List 2.1 ArrayList、LinkedList 区别 2.1.1 底层实现 🔹 ArrayList：数组🔹 LinkedList：双向链表（1.7~），1.7之前是循环链表。 循环链表相比双向链表的缺点：&emsp;1️⃣ 初始化时，需先创建一个空节点作为头节点，以避免需要多次校验头节点是否为null。&emsp;2️⃣ 头尾部节点不够清晰，且在头尾部分进行增删时，需处理头尾部两个节点的指针。 2.1.2 增删元素 🔹 ArrayList：默认时，复杂度O(1)。指定位置时，复杂度O(n-i)。 增删某元素将对后续元素位置产生影响。不指定位置则默认增加到尾部。🔹 LinkedList: 复杂度O(1)。 2.1.3 查找元素 🔹 ArrayList：可快速查询🔹 LinkedList：需遍历查询 2.1.4 线程安全性 🔹 两者都是非线程安全的 2.1.5 空间占用 🔹 ArrayList：需要预留容量空间🔹 LinkedList：每个节点需存储前继和后续节点的指针 2.1.6 扩容 🔹 ArrayList：+50%,初始值10🔹 LinkedList：且无需扩容,无初始值 2.2 ArrayList、Vector 区别 2.2.1 线程安全性 🔹 ArrayList：非线程安全🔹 Vector：线程安全 2.2.2 效率 🔹 ArrayList：效率更高🔹 Vector：效率低 Vector每个方法都添加了同步，即Synchronized。导致效率低。 2.2.3 扩容 🔹 ArrayList：增加 50%，初始容量10🔹 Vector：增加 100%，初始容量10 12//ArrayList的grow中的增加的值int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); 3. Map and Set 3.1 HashMap 与 HashTable(不使用) 3.1.1 底层实现 🔹 HashMap: 数组+红黑树+链表(1.8~),1.8前是数组+链表&emsp; jdk1.8，为了解决哈希冲突所带来的问题，当链表长度大于阈值(默认为8)，且当前长度不小于64，则将链表转为红黑树。若长度小于64，则是进行扩容。🔹 HashTable: 数组+链表 3.1.2 线程安全性 🔹 HashMap：线程不安全。若需线程安全可使用ConcurrentHashMap🔹 HashTable：线程安全。几乎大部分方法都加了同步 3.1.3 效率 🔹 HashMap：效率高🔹 HashTable：效率低 3.1.4 扩容 🔹 HashMap:增加一倍。初始值为16。扩容因子默认为0.75&emsp;若指定大小时，长度将为比该值稍大或等于的2的幂次方。这是由于hash%length==hash&amp;(2^n-1)，且&amp;的效率高于%。&emsp;eg: 指定值为50, 50 &lt; 2^6. 故容量为2^6=16 🔹 HashTable:增加一倍,再+1.初始值为11 3.1.5 null值的处理 🔹 HashMap:key和value都支持null值，key仍不可重复🔹 HashTable:抛NullPointerException 3.2 HashMap 与 HashSet 3.2.1 底层实现 HashSet底层与HashMap一致，其内部调用了HashMap的方法。 1234567891011//HashSet 中的代码：其中的方法实现是通过HashMap代理来实现private transient HashMap&lt;E,Object&gt; map;private static final Object PRESENT = new Object();public int size() &#123; return map.size();&#125;public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; 3.2.2 对Hashcode的计算 🔹 HashMap：根据key和value进行运算🔹 HashSet：没有重写HashCode方法，value值以空对象代替。 123456789101112131415161718192021//该节点类为HashMap中内部类static class Node&lt;K, V&gt; implements Entry&lt;K, V&gt; &#123; //key和value的地址进行异或运算（不同则1，相同则0） public final int hashCode() &#123; return Objects.hashCode(this.key) ^ Objects.hashCode(this.value); &#125; public final boolean equals(Object var1) &#123; if (var1 == this) &#123; return true; &#125; else &#123; if (var1 instanceof Entry) &#123; Entry var2 = (Entry)var1; if (Objects.equals(this.key, var2.getKey()) &amp;&amp; Objects.equals(this.value, var2.getValue())) &#123; return true; &#125; &#125; return false; &#125; &#125;&#125; 📁内容补充：hashcode() 与 equals() 🔹 Object中的hashcode()，是关于其该对象实例的内存地址。🔹 Map中，hashcode 相同，equals不一定相等，表示在同一个散列数据结构（链表）。equal相等，hashcode一定相等。🔹 由于hashcode存在冲突，故需要使用equals进行判断。 3.3 ConcurrentHashMap 与 HashTable 两者都是线程安全。HashTable几乎所有方法都添加了同步，效率低。JDK1.7的ConcurrentHashMap则是来取代HashTable。 3.3.1 底层实现 🔹 ConcurrentHashMap：同HashMap🔹 HashTable：数组+链表 3.3.2 线程安全的策略 🔹 ConcurrentHashMap：使用“分段式锁”。&emsp;每一段数据分别加锁。而且加的锁是ReentrantLock可重入锁。&emsp;👉图片来源 🔹 HashTable：大部分方法添加了同步。如put/get方法添加了Synchronzed。&emsp;效率很低，近似整个容器对象添加了锁。&emsp;👉图片来源","categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"个人笔记/Java","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/"},{"name":"基础","slug":"个人笔记/Java/基础","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/%E5%9F%BA%E7%A1%80/"},{"name":"容器","slug":"个人笔记/Java/基础/容器","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/%E5%9F%BA%E7%A1%80/%E5%AE%B9%E5%99%A8/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jianxilin.github.io/tags/Java/"},{"name":"Java容器","slug":"Java容器","permalink":"https://jianxilin.github.io/tags/Java%E5%AE%B9%E5%99%A8/"}]},{"title":"[总结]Git的基本使用","slug":"总结-Git的基本使用","date":"2020-05-13T03:48:49.000Z","updated":"2020-05-13T06:49:27.859Z","comments":true,"path":"2020/05/13/总结-Git的基本使用/","link":"","permalink":"https://jianxilin.github.io/2020/05/13/%E6%80%BB%E7%BB%93-Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"Git作为一个版本控制的工具,在我们学习过程中是必不可少的。不仅是Git仓库GitHub、Gitee，还是在编辑器VSCode，Git在管理文件、控制文件版本、回退文件、多人协作、并发开发等有着重要的地位。以下将对Git的基本使用继续总结、记录。","text":"Git作为一个版本控制的工具,在我们学习过程中是必不可少的。不仅是Git仓库GitHub、Gitee，还是在编辑器VSCode，Git在管理文件、控制文件版本、回退文件、多人协作、并发开发等有着重要的地位。以下将对Git的基本使用继续总结、记录。 1. Git与SVN的简单区分 🔹 实现方式上&emsp;SVN : 集中版本控制。SVN所控制的所有版本内容存储在单一服务器上，本地用户在未联网的情况下，只能看到所同步的版本内容。&emsp;Git : 分布式版本控制。不同于SVN，本地的每个本地用户都能获取到所有版本内容，且Commit操作是在用户本地进，之后再push到远端仓库。&emsp;Git相比SVN，空间成本增加了，且安全性也有所下降，但也减少了数据损失而无法恢复的风险。 🔹 克隆多分支项目&emsp;SVN克隆所有分支的内容&emsp;Git克隆master分支,其它分支只获取相关元素，节省了时间。 2. Git的基本使用 2.1 配置信息 🔹 获取配置信息： 123456// 获取全部配置信息git config -l// 获取系统级别配置信息，对应 \\git主目录\\etc\\gitconfiggit config --system -l// 获取用户(全局)级别的配置信息，对应 \\user\\Administrator\\.gitconfiggit config --global -l 🔹 配置全局的用户信息 12git config --global user.name \"用户名\"git config --global user.email 邮箱 2.2 操作仓库内容 🔹 初始化本地仓库 1git init 🔹 添加到缓存并提交到本地仓库 12git add . git commit -m \"注释\\提交的说明信息\" 🔹 提交到远程仓库 1git push 地址 master 🔹 克隆远程仓库 \\ 获取远程代码 12git clone 地址 分支(eg:master)git pull 地址 分支(eg:master) 🔹 查看本地文件状态 1git status 3.HEAD HEAD 指当前分支的最近一次提交head 指commit对象 head 包含 HEAD 🔹 占位符 ~ 与 ^ ~ ： 表示祖先commit&emsp;&emsp;eg : HEAD~ = HEAD~1 = 前一代commit（父辈）&emsp;&emsp;&emsp;HEAD~~ = HEAD~2 = 前两代commit（爷爷辈）^ : 单个父辈时，与 ~ 基本一致。&emsp;&emsp;多个父辈时，^ = ^1 = 第一个父辈 🔹 案例 1234567891011121314151617181920G H I J \\ / \\ / D E F \\ | / \\ \\ | / | \\|/ | B C \\ / \\ / AA = = A^0B = A^ = A^1 = A~1C = A^2 = A^2D = A^^ = A^1^1 = A~2E = B^2 = A^^2F = B^3 = A^^3G = A^^^ = A^1^1^1 = A~3H = D^2 = B^^2 = A^^^2 = A~2^2I = F^ = B^3^ = A^^3^J = F^2 = B^3^2 = A^^3^2 👉此内容参考来源 4. 信息查看 🔹 获取本地文件状态 1git status 🔹 获取commit历史信息 12git loggit log --oneline 🔹 查看当前索引(暂存区) 1git ls-files -s 🔹 显示了 HEAD 快照实际的目录列表 1git cat-file -p HEAD 🔹 查看HEAD的当前指向 1cat .git/HEAD 🔹 查看HEAD各个祖先 1git rev-parse HEAD~ //前一个祖先(父辈) 5. 撤销操作 🔹 git checkout [不写|HEAD] &lt;file&gt; //旧版 🔹 git restore [不写|–staged] &lt;file&gt; //新版 🔹 git reset [–hard|soft|mixed(默认)|merge|keep] [commit|HEAD](1) –soft : 回退到暂存区状态(2) –mixed : 回退到本地状态（本地修改的内容存在）(3) –hard : 回退到某次提交，清除所有历史状态，包括本地文件内容。 🔹 git revert HEAD^ 重新提交，保留历史记录 git reset不保留历史记录 🔹 重写最后一次commit 1git commit --amend -m 6. 冲突解决 🔹 提交时，发生冲突 执行git pull，发生冲突后，git会将两个版本的内容合并在一起。解决：先git status，查找发生冲突的文件，自行修改冲突内容后再提交，pull 🔹 回退commit，发生冲突 执行revert HEAD^，发生冲突。解决：同样查看冲突、修改冲突后，执行git revert –continue。 7. Git的分支处理 🔹 常用命令 12345678910111213141516171819202122232425# 列出所有本地分支git branch# 列出所有远程分支git branch -r# 新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支git checkout -b [branch]# 切换分支git checkout [branch]# 合并指定分支到当前分支$ git merge [branch]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 👉此内容来源 参考文章：狂神说 聊Git📘CSDN 奋飛 Git Pro深入浅出（二）📘","categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"name":"工具","slug":"个人笔记/工具","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7/"},{"name":"版本控制","slug":"个人笔记/工具/版本控制","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"Git","slug":"个人笔记/工具/版本控制/Git","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/"}],"tags":[{"name":"版本控制","slug":"版本控制","permalink":"https://jianxilin.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"Git","slug":"Git","permalink":"https://jianxilin.github.io/tags/Git/"}]},{"title":"[总结]CSS样式失效的原因","slug":"总结-CSS样式失效的原因","date":"2020-05-11T06:49:33.000Z","updated":"2020-05-11T08:50:02.318Z","comments":true,"path":"2020/05/11/总结-CSS样式失效的原因/","link":"","permalink":"https://jianxilin.github.io/2020/05/11/%E6%80%BB%E7%BB%93-CSS%E6%A0%B7%E5%BC%8F%E5%A4%B1%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0/","excerpt":"CSS样式生效，需要正确的语法，并且其样式内容不被覆盖。以下先总结三点原因（后续再补充）：🔹 错误使用单行注释🔹 CSS选择器优先级较低🔹 Chrome浏览器存在CSS文件缓存","text":"CSS样式生效，需要正确的语法，并且其样式内容不被覆盖。以下先总结三点原因（后续再补充）：🔹 错误使用单行注释🔹 CSS选择器优先级较低🔹 Chrome浏览器存在CSS文件缓存 1. 在外部CSS中不能使用单行注释 在CSS选择器上使用单行注释，将导致该注释下的这个CSS选择器里面的内容失效。如下代码所示,“.post-readmore__link{}”将失效,“.post-readmore__link:hover{}”有效，不会受到影响。 1234567//readmore button （第一个CSS选择器无效）.post-readmore__link&#123; background-color: #27ae60;&#125;.post-readmore__link:hover&#123; background-color: #1f7f47;&#125; 而单行注释添加在CSS样式内，该CSS仍有效 123.post-readmore__link&#123; background-color: #27ae60; //green （有效）&#125; 若需要使用注释，可使用多行注释。如下： 1234/* readmore button */.post-readmore__link&#123; background-color: #27ae60; //green （有效）&#125; 2. CSS选择器优先级低于原有的CSS选择器 2.1. 当多个CSS选择器选择目标相同时 🔹 级别相同，后加载的CSS选择器覆盖前CSS选择器中相同的样式。🔹 级别不同，高级别CSS选择器覆盖低级别CSS选择器中相同的样式。 2.2. 级别判断 🔹 内嵌式CSS级别高于外部CSS，可视为最高级别。 🔹 #ID &gt; .Class、属性选择器([type=”button”])和伪类(:hover) &gt; 标签类型和伪元素(::after)级别计算案例：图片内容来源：MDN Web Docs 🔹 使用!important覆盖任何样式声明 123.post-readmore__link&#123; background-color: #27ae60 !important;&#125; 对于都添加！important的样式，则再由其选择器优先级来判断。 3.chrome浏览器存在缓存 🔹 原因:&emsp;&emsp;chrome浏览器为了提高加载效率，缓存了JS、CSS文件，故修改后的文件无法立即生效。 🔹 解决方法：方式一：来回切换开启缓存来重置缓存内容（不一定有效）。&emsp;&emsp;F12打开开发者工具，进入Network，在Disable cache前打勾✔，刷新页面。再把Disable cache关闭，取消✔，再次刷新页面。 方式二：来回切换开启缓存来重置缓存内容&emsp;&emsp;F12打开开发者工具，然后在浏览器的刷新按钮右击，选择“清空缓存并硬性重新加载”","categories":[{"name":"踩坑记录","slug":"踩坑记录","permalink":"https://jianxilin.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"},{"name":"前端","slug":"踩坑记录/前端","permalink":"https://jianxilin.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"踩坑记录/前端/CSS","permalink":"https://jianxilin.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://jianxilin.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"CSS","permalink":"https://jianxilin.github.io/tags/CSS/"}]},{"title":"个人博客[2]——美化","slug":"个人博客-2-——美化","date":"2020-05-11T06:46:50.000Z","updated":"2020-05-11T06:56:49.141Z","comments":true,"path":"2020/05/11/个人博客-2-——美化/","link":"","permalink":"https://jianxilin.github.io/2020/05/11/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-2-%E2%80%94%E2%80%94%E7%BE%8E%E5%8C%96/","excerpt":"环境要求：node.js 和 npm基于 Hexo博客框架基于 Hexo主题stun 美化内容以下：🔹 主题设置🔹 博客主题样式自定义🔹 博客文章样式自定义","text":"环境要求：node.js 和 npm基于 Hexo博客框架基于 Hexo主题stun 美化内容以下：🔹 主题设置🔹 博客主题样式自定义🔹 博客文章样式自定义 效果图： 👉Hexo官方地址 👉Hexo-theme-stun官方地址 1. 修改主题 1.1. 下载主题(stun) git clone https://github.com/liuyib/hexo-theme-stun.git themes/stun 1.2. 配置主题 修改_config.yml 123#Extensions...theme: yilia 1.3. Hexo重设与发布 清除 hexo clean 创建 hexo g 启动 hexo s 推到远端 hexo d 2. 基本样式修改 主题的相关设置详见官方文档📗 可修改Hexo主路径下的_config.yml,将生效于所有主题。也可修改hexo/theme/stun下的_config.xml,将只生效于stun主题。 2.1. 修改博客图标等图片 🔹 方式一：覆盖原图像 在Hexo主路径下的\\themes\\stun\\source\\images\\icons中，使用相同大小的图片覆盖。之后查看stun下的_config.xml是否开启对应的功能。 🔹 方式二：自定义路径 在_config.xml相应的配置下，设置图片路径为自定义图片路径（Hexo下的路径、图床上的路径） 2.2. 修改网页样式 🔹 修改文章样式 将CSS样式添加到stun主题的路径下的\\source\\css_custom\\index.styl文件内即可。内容如下： 1234567891011121314151617// Custom styles by yourself.// You should always modify the style here, not in the source code.// Otherwise, when the theme is updated, the code you modified will be overwritten.body &#123; // modify your style here // eg: background-color: blue; h1 &#123; text-align: center; &#125; h1, h2&#123; color: #4CAF50; &#125; ...&#125; 🔹 修改博客样式 （1）在stun主题的路径下的\\source\\css创建文件夹，自定义名称，名称前需带”_”，例如：_myCss。在该创建的文件夹下放置个人的CSS文件。（2）配置CSS文件。在stun\\source\\css\\index.styl文件内添加以下内容：@import ‘个人的CSS文件全路径’如下： 12345678910111213141516// Variables Layer// --------------------------------------------------@import './_variables/index.styl';// Mixins Layer// --------------------------------------------------@import './_mixins/index.styl';// Common Layer// --------------------------------------------------@import './_common/index.styl';// Custom Layer// --------------------------------------------------@import './_custom/index.styl';// MyCSS// --------------------------------------------------@import './_myCss/myCss.css';","categories":[{"name":"个人博客","slug":"个人博客","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"个人博客","slug":"个人博客","permalink":"https://jianxilin.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}]},{"title":"个人博客[3]——写作","slug":"个人博客-3-——写作","date":"2020-05-11T06:44:24.000Z","updated":"2020-05-11T06:55:24.757Z","comments":true,"path":"2020/05/11/个人博客-3-——写作/","link":"","permalink":"https://jianxilin.github.io/2020/05/11/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-3-%E2%80%94%E2%80%94%E5%86%99%E4%BD%9C/","excerpt":"环境要求：node.js 和 npm基于 Hexo博客框架基于 Hexo主题stun 本文内容包含：🔹 创建、修改、删除文章🔹 创建分类、标签页面🔹 在stun主题内开启分页和标签页面","text":"环境要求：node.js 和 npm基于 Hexo博客框架基于 Hexo主题stun 本文内容包含：🔹 创建、修改、删除文章🔹 创建分类、标签页面🔹 在stun主题内开启分页和标签页面 1. 创建 具体操作见官方文档📗 1.1. 创建文章 12hexo n \"文章名称\"hexo c &amp; hexo g 1.2. 创建分类、标签页面（即创建页面） 🔹 创建分类页面 在Hexo主路径下，执行以下命令 1hexo new page categories 在文章编写时，在文章顶部的Front-matter添加分类信息： 1234categories： - 分类名称 - 下一级分类名称 - [同级分类名称...] 🔹 创建标签页面 与创建分页页面相同，将categories改为tags即可。不同的是，Front-matter中的tags没有分级。 例子： 12345678910---title: '个人博客[1]——搭建'date: 2020-05-10 17:39:21tags: 个人博客categories: - 个人博客photos: - url--- 🔹 在stun主题内开启分页和标签页面 在stun主路径下的_config.yml配置文件的menu节点下添加页面配置信息，如下 1234567menu: home: / || fas fa-home archives: /archives/ || fas fa-folder-open categories: /categories/ || fas fa-layer-group tags: /tags/ || fas fa-tags # You can add a secondary menu like follow. # xxx1: javascript:; || fa(s|r|l|d|b) fa-xxx 效果图： 2.修改 2.1. 修改文章名称 &emsp;&emsp;Hexo未提供修改文件名称的命令。 🔹 解决方法： &emsp;&emsp;最简单的方式就是重新创建该文章，将要修改文章迁移过去。单独修改文章名称和修改文章内的Title标签是无效的。&emsp;&emsp;也可使用hexo-console-renamer插件，后续使用后再来补充。 2.2 删除文章 &emsp;&emsp;同样的，Hexo未提供删除文章的命令。 🔹 解决方法： &emsp;&emsp;在Hexo主路径下的\\source_posts文件夹内，手动删除文章文件，之后再重新创建博客内容，即运行以下命令 1hexo c &amp; hexo g","categories":[{"name":"个人博客","slug":"个人博客","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"个人博客","slug":"个人博客","permalink":"https://jianxilin.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}]},{"title":"个人博客[1]——搭建","slug":"个人博客-1-——搭建","date":"2020-05-10T09:39:21.000Z","updated":"2020-05-11T04:32:41.744Z","comments":true,"path":"2020/05/10/个人博客-1-——搭建/","link":"","permalink":"https://jianxilin.github.io/2020/05/10/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-1-%E2%80%94%E2%80%94%E6%90%AD%E5%BB%BA/","excerpt":"环境要求：node.js 和 npm基于 Hexo博客框架 👉Hexo官方地址","text":"环境要求：node.js 和 npm基于 Hexo博客框架 👉Hexo官方地址 1. 配置环境 安装node.js和npm修改npm的镜像为阿里镜像，即按照cnpm 安装cnpm cmd命令： &emsp;&emsp;npm install -g cnpm –registry=https://registry.npm.taobao.org 安装测试： &emsp;&emsp;cnpm -v 2. 安装Hexo框架 2.1. 安装：cnpm install -g hero-cli 2.2. 验证安装：hexo -v 3. 初始化Hexo博客 3.1. 初始化hexo项目：hexo init 3.2. 启动项目：hexo s 4. 添加第一篇文章 👉Hexo官方:写作 创建新文章：hexo n 文件名 清理：hexo clean 生成文章：hexo g 重启：hexo s 5. 部署到GitHub上 5.1. 创建git仓库,名称为 “git账号名.github.io”5.2. 安装github部署插件。 在本地博客路径下，运行 cnpm install –save hexo-deployer-git 5.3. 添加仓库信息 修改_config.yml。 在#deployment节点下，内容如下： ==冒号后需 + 空格== 12345#deploymentdeploy: type: git repo: 仓库地址 branch: master5.4. 部署到远端 hexo d","categories":[{"name":"个人博客","slug":"个人博客","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"个人博客","slug":"个人博客","permalink":"https://jianxilin.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}]}],"categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"个人笔记/Java","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/"},{"name":"基础","slug":"个人笔记/Java/基础","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/%E5%9F%BA%E7%A1%80/"},{"name":"容器","slug":"个人笔记/Java/基础/容器","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/%E5%9F%BA%E7%A1%80/%E5%AE%B9%E5%99%A8/"},{"name":"工具","slug":"个人笔记/工具","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7/"},{"name":"版本控制","slug":"个人笔记/工具/版本控制","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"Git","slug":"个人笔记/工具/版本控制/Git","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/"},{"name":"踩坑记录","slug":"踩坑记录","permalink":"https://jianxilin.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"},{"name":"前端","slug":"踩坑记录/前端","permalink":"https://jianxilin.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"踩坑记录/前端/CSS","permalink":"https://jianxilin.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/%E5%89%8D%E7%AB%AF/CSS/"},{"name":"个人博客","slug":"个人博客","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jianxilin.github.io/tags/Java/"},{"name":"Java容器","slug":"Java容器","permalink":"https://jianxilin.github.io/tags/Java%E5%AE%B9%E5%99%A8/"},{"name":"版本控制","slug":"版本控制","permalink":"https://jianxilin.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"Git","slug":"Git","permalink":"https://jianxilin.github.io/tags/Git/"},{"name":"前端","slug":"前端","permalink":"https://jianxilin.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"CSS","permalink":"https://jianxilin.github.io/tags/CSS/"},{"name":"个人博客","slug":"个人博客","permalink":"https://jianxilin.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}]}