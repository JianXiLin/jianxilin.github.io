{"meta":{"title":"Jianxi's Blog","subtitle":"Learn to code and share","description":"","author":"JianxiLin","url":"https://jianxilin.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-05-10T16:01:52.000Z","updated":"2020-05-10T16:06:36.161Z","comments":true,"path":"categories/index.html","permalink":"https://jianxilin.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-10T16:02:27.000Z","updated":"2020-05-10T16:06:09.613Z","comments":true,"path":"tags/index.html","permalink":"https://jianxilin.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"validation的基本使用","slug":"validation的基本使用","date":"2020-05-27T13:26:39.000Z","updated":"2020-05-27T13:55:53.527Z","comments":true,"path":"2020/05/27/validation的基本使用/","link":"","permalink":"https://jianxilin.github.io/2020/05/27/validation%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"1、jar包引入 12345&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.0.9.Final&lt;/version&gt;&lt;/dependency&gt;","text":"1、jar包引入 12345&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.0.9.Final&lt;/version&gt;&lt;/dependency&gt; 2、校验注解 不仅仅只是可用在实体类中，也可用在（使用了@Validated ）controller、service的方法参数，service方法返回值。注解一般不会处理null情况。 👉原文链接 注解 使用 @NotNull 被注释的元素（任何元素）必须不为 null, 集合为空也是可以的。没啥实际意义 @NotEmpty 用来校验字符串、集合、map、数组不能为null或空 （字符串传入空格也不可以）（集合需至少包含一个元素） @NotBlank 只用来校验字符串不能为null，空格也是被允许的 。校验字符串推荐使用@NotEmpty @Size(max=, min=) 指定的字符串、集合、map、数组长度必须在指定的max和min内 允许元素为null，字符串允许为空格，==为null时，不生效。== @Length(min=,max=) 只用来校验字符串，长度必须在指定的max和min内 允许元素为null @Range(min=,max=) 用来校验数字或字符串的大小必须在指定的min和max内，字符串会转成数字进行比，如果不是数字校验不通过，允许元素为null @Min() 校验数字（包括integer short long int 等）的最小值，不支持小数即double和float，允许元素为null @Max() 校验数字（包括integer short long int 等）的最小值，不支持小数即double和float，允许元素为null @Pattern() 正则表达式匹配，可用来校验年月日格式，是否包含特殊字符（regexp = “^[a-zA-Z0-9\\u4e00-\\u9fa5 🔹 不常用 123456789@Null 被注释的元素必须为 null@AssertTrue 被注释的元素必须为 true@AssertFalse 被注释的元素必须为 false@DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值@DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值@Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内@Past 被注释的元素必须是一个过去的日期@Future 被注释的元素必须是一个将来的日期@Email 被注释的元素必须是电子邮箱地址 3、注解 3.1、@Validated 3.2、@RestController 3.3、@Valid 标记需验证的参数，可用于controller中方法的参数，也可在spring中， 可用于联级验证中的一对一、一对多。 A、一对一: 一个对象中包含另一个对象作为属性。 对这个对象属性添加该注解，这该对象中的验证也可使用。 B、一对多：一个对象中包含另一个对象容器作为属性。 注解可加在属性上，也可加载list泛型前。 3.4 @ExceptionHandler 在spring中，添加该注解的方法可对某异常进行捕获。 例如：MethodArgumentNotValidException e 4、在service中添加参数验收 4.1、实现方法 同controller。在类上添加@Validated，之后在需要进行参数验收 的参数前添加@Vaild。 4.2、注意事项 A、注解添加的位置。 @Vaild ：不能添加在接口实现类中，需放置在service的接口类中。 @Vaildated ：可添加在实现类或接口类中。 添加在接口类时，其对应的实现类也会进行参数验收。 B、需捕获的异常不同于controller。 并不是MethodArgumentNotValidException， 而是ConstraintViolationException(原生态的异常) 5、分组验收 无法使用于Service中 5.1、使用场景 对于不同功能，其对同一个实体的验证需求不同，则需要使用分组验收。 例如：添加新用户时，用户id需要为空值。而修改用户时，用户id则不能为空值。 5.2、实现 1️⃣ A、设置分组 利用参数验证注解中的groups参数。 未设置分组的参数属于默认分组 2️⃣ 指定分组 由于@Valid无法实现该功能，故需使用@Validated来标记需参数验收的参数。 利用@Validated的value来指定分组。 6、自定义注解 6.1 实现 A、实现注解（eg：MultipleOfThree） B、实现业务处理类（实现 ConstrainValidator接口） 7、校验List中的参数 7.1、获取validtor 1️⃣ 获取validtor 2️⃣ 从SpringBoot中获取(创建工具类获取，不直接注入到使用类中，因为Validtor非单例) 7.2、创建自定义注解 7.3、创建注解处理类 1️⃣ 注解处理类 2️⃣ 自定义异常类(由于处理类默认返回boolean,需改成抛出异常) 3️⃣ 捕获该异常类 4️⃣ 使用注解 8、参数间的逻辑校验 8.1、实现思路（分组动态化） 🔹 利用hibernate.validator 中提供的SequenceProvider——可进行分组的添加 &emsp;&emsp;通过SequenceProvider 来根据被校验的对象的属性变化，对添加分组。 8.2、实现方法 1️⃣ 创建SequenceProvider，在添加默认分组后，进行逻辑判断，以添加不同分组。 2️⃣ 使用SequenceProvider，在实体类中使用@GroupSequenceProvider","categories":[{"name":"java","slug":"java","permalink":"https://jianxilin.github.io/categories/java/"},{"name":"validation","slug":"java/validation","permalink":"https://jianxilin.github.io/categories/java/validation/"}],"tags":[{"name":"java vaildation 数据校验","slug":"java-vaildation-数据校验","permalink":"https://jianxilin.github.io/tags/java-vaildation-%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/"}]},{"title":"axios的基本使用","slug":"axios的基本使用","date":"2020-05-27T12:58:49.000Z","updated":"2020-05-27T13:13:12.694Z","comments":true,"path":"2020/05/27/axios的基本使用/","link":"","permalink":"https://jianxilin.github.io/2020/05/27/axios%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"1. 简介 基于promise的对ajax的一个封装ajax适合于mvcpromise则适用于mvvm","text":"1. 简介 基于promise的对ajax的一个封装ajax适合于mvcpromise则适用于mvvm 2.使用 2.1 基本写法 123456789101112131415&lt;script src=\"https:unpkg.com.axios/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;script&gt; axios(&#123; url:\"url\", method:'get'|'post', //get为默认方式 param:&#123;--&#125; // param:&#123;name:小明&#125; //用过于get方法传参 同添加到url中 //post使用该参数，同样也是将参数添加到url中 data:&#123;--&#125; //用于post方法传参数 &#125;).then(res=&gt;&#123; console.log(res) &#125;).catch(err=&gt;&#123; console.log(err) &#125;)&lt;/script&gt; post传参注意点:带参请求默认为使用 application/json。1.param 可实现传参，但参数添加到url中2.使用axios.post(‘url’,’data’)3.使用data参数，后端对数据进行处理。如Springboot中使用@requestBody,将json转为java对象。 2.2 简写 2.2.1 get 1234567891011&lt;script src=\"https:unpkg.com.axios/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;script&gt; axios.get(&#123; \"url\", &#123;params:&#123;--&#125;&#125; // &#123;params:&#123;name:小明&#125;&#125; &#125;).then(res=&gt;&#123; console.log(res) &#125;).catch(err=&gt;&#123; console.log(err) &#125;)&lt;/script&gt; 2.2.2 post 123456789101112&lt;script src=\"https:unpkg.com.axios/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;script&gt; axios.post(&#123; \"url\", \"data\", // \"name=小明&amp;age=20\" &#123;data&#125; // &#123;data:&#123;name:'小明'&#125;&#125; &#125;).then(res=&gt;&#123; console.log(res) &#125;).catch(err=&gt;&#123; console.log(err) &#125;)&lt;/script&gt; 3.发送多个请求 3.1 使用res数组获取多个请求结果 1234567891011&lt;script src=\"https:unpkg.com.axios/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;script&gt; axios.all(&#123; axios.get(--), axios.get(--) &#125;).then(res=&gt;&#123; console.log(res[0]+res[1]) &#125;).catch(err=&gt;&#123; console.log(err) &#125;)&lt;/script&gt; 3.2 使用axios.spread()获取多个请求结果 12345678910111213&lt;script src=\"https:unpkg.com.axios/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;script&gt; axios.all(&#123; axios.get(--), axios.get(--) &#125;).then( axios.spread((res1,res2)=&gt;&#123; console.log(res1+res2) &#125;) &#125;).catch(err=&gt;&#123; console.log(err) &#125;)&lt;/script&gt; 4. 全局配置 可将公共数据提取出来，get、post请求内容中则无需再写这些公共内容。比如提取url的公共部分、提取超时参数。 1234567891011&lt;script src=\"https:unpkg.com.axios/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;script&gt; axios.defaults.baseurl=\"http://-:8080/person\", axios.defaults.timeout=3000, axios.get('getall').then(res=&gt;&#123; // == http://-:8080/person/getall console.log(res) &#125;) axios.post('update').then(res=&gt;&#123; // == http://-:8080/person/update console.log(res) &#125;)&lt;/script&gt; 5. axios实例 12345678910111213&lt;script src=\"https:unpkg.com.axios/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;script&gt; // 定义 let newVar = axios.create(&#123; baseURL:'url', timeout:5000 &#125;); // 使用 newVar(&#123; url:'getAll' &#125;)&lt;/script&gt; 6. 拦截器 12345678&lt;script src=\"https:unpkg.com.axios/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;script&gt; axios.interceptors.request.use(config=&gt;&#123; // 进入前 &#125;,err=&gt;&#123; // 发生错误 &#125;);&lt;/script&gt; 7. 在vue中进行模块封装 基于 import-export 来进行封装，类似函数封装 vue中安装axios: npm install axios –save 7.1 无返回值 🔹 封装内容 (位置 : /network/request/request.js): 12345678910import axios form 'axios'export function request(url,success,fail)&#123; axios(&#123; url:url &#125;).then(res=&gt;&#123; success(res) &#125;).catch(err=&gt;&#123; fail(err) &#125;)&#125; 🔹 调用: 12import &#123;request&#125; form './network/request/request.js'request(url,res=&gt;&#123;&#125;,err=&gt;&#123;&#125;) 7.2 返回Promise对象 Promise中需声明、创建实例.Promise为ES6中的语法点，其内容代指即将发生的事件 🔹 封装内容： 12345678910111213141516import axios form 'axios'export function request(config)&#123; return new Promise((resolve,reject)=&gt;&#123; //声明实例 let newVar = axios.create(&#123; baseURL:\"url\", timeout:5000 &#125;); //创建实例 newVar(config).then(res=&gt;&#123; resolve(res) //res将作为参数传给回调函数 &#125;).catch(err=&gt;&#123; reject(err) &#125;) &#125;)&#125; 🔹 调用 12import &#123;request&#125; form './network/request/request.js'request(&#123;url:'url'&#125;).then(res=&gt;&#123;&#125;).catch(err=&gt;&#123;&#125;) 7.3 返回实例 方法内声明实例。本质同返回Promise对象 🔹 封装内容： 12345678910import axios form 'axios'export function request(config)&#123; //声明实例 let newVar = axios.create(&#123; baseURL:\"url\", timeout:5000 &#125;); //创建实例并返回 return newVar(config);&#125; 🔹 调用 12import &#123;request&#125; form './network/request/request.js'request(&#123;url:'url'&#125;).then(res=&gt;&#123;&#125;).catch(err=&gt;&#123;&#125;)","categories":[{"name":"前端","slug":"前端","permalink":"https://jianxilin.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"axios","slug":"前端/axios","permalink":"https://jianxilin.github.io/categories/%E5%89%8D%E7%AB%AF/axios/"}],"tags":[{"name":"前端 axios","slug":"前端-axios","permalink":"https://jianxilin.github.io/tags/%E5%89%8D%E7%AB%AF-axios/"}]},{"title":"[总结]Java容器","slug":"总结-Java容器","date":"2020-05-21T07:42:36.000Z","updated":"2020-05-21T07:45:29.851Z","comments":true,"path":"2020/05/21/总结-Java容器/","link":"","permalink":"https://jianxilin.github.io/2020/05/21/%E6%80%BB%E7%BB%93-Java%E5%AE%B9%E5%99%A8/","excerpt":"1. List、Map、Set 🔹 List: 用于排序。元素有序、可重复。&emsp;&emsp;&emsp;&emsp;实现：Object数组 | 双向链表🔹 Map：用于搜索。存储键值对。key不可重复。&emsp;&emsp;&emsp;&emsp;实现：数组+链表（JDK1.8前），数组+链表+红黑树（JDK1.8~）🔹 Set：无重复（去重）。不可重复。&emsp;&emsp;&emsp;&emsp;实现：使用Map中的Key","text":"1. List、Map、Set 🔹 List: 用于排序。元素有序、可重复。&emsp;&emsp;&emsp;&emsp;实现：Object数组 | 双向链表🔹 Map：用于搜索。存储键值对。key不可重复。&emsp;&emsp;&emsp;&emsp;实现：数组+链表（JDK1.8前），数组+链表+红黑树（JDK1.8~）🔹 Set：无重复（去重）。不可重复。&emsp;&emsp;&emsp;&emsp;实现：使用Map中的Key RandomAccess：标记型接口。表示可随机访问元素（可快速访问）。 2. List 2.1 ArrayList、LinkedList 区别 2.1.1 底层实现 🔹 ArrayList：数组🔹 LinkedList：双向链表（1.7~），1.7之前是循环链表。 循环链表相比双向链表的缺点：&emsp;1️⃣ 初始化时，需先创建一个空节点作为头节点，以避免需要多次校验头节点是否为null。&emsp;2️⃣ 头尾部节点不够清晰，且在头尾部分进行增删时，需处理头尾部两个节点的指针。 2.1.2 增删元素 🔹 ArrayList：默认时，复杂度O(1)。指定位置时，复杂度O(n-i)。 增删某元素将对后续元素位置产生影响。不指定位置则默认增加到尾部。🔹 LinkedList: 复杂度O(1)。 2.1.3 查找元素 🔹 ArrayList：可快速查询🔹 LinkedList：需遍历查询 2.1.4 线程安全性 🔹 两者都是非线程安全的 2.1.5 空间占用 🔹 ArrayList：需要预留容量空间🔹 LinkedList：每个节点需存储前继和后续节点的指针 2.1.6 扩容 🔹 ArrayList：+50%,初始值10🔹 LinkedList：且无需扩容,无初始值 2.2 ArrayList、Vector 区别 2.2.1 线程安全性 🔹 ArrayList：非线程安全🔹 Vector：线程安全 2.2.2 效率 🔹 ArrayList：效率更高🔹 Vector：效率低 Vector每个方法都添加了同步，即Synchronized。导致效率低。 2.2.3 扩容 🔹 ArrayList：增加 50%，初始容量10🔹 Vector：增加 100%，初始容量10 12//ArrayList的grow中的增加的值int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); 3. Map and Set 3.1 HashMap 与 HashTable(不使用) 3.1.1 底层实现 🔹 HashMap: 数组+红黑树+链表(1.8~),1.8前是数组+链表&emsp; jdk1.8，为了解决哈希冲突所带来的问题，当链表长度大于阈值(默认为8)，且当前长度不小于64，则将链表转为红黑树。若长度小于64，则是进行扩容。🔹 HashTable: 数组+链表 3.1.2 线程安全性 🔹 HashMap：线程不安全。若需线程安全可使用ConcurrentHashMap🔹 HashTable：线程安全。几乎大部分方法都加了同步 3.1.3 效率 🔹 HashMap：效率高🔹 HashTable：效率低 3.1.4 扩容 🔹 HashMap:增加一倍。初始值为16。扩容因子默认为0.75&emsp;若指定大小时，长度将为比该值稍大或等于的2的幂次方。这是由于hash%length==hash&amp;(2^n-1)，且&amp;的效率高于%。&emsp;eg: 指定值为50, 50 &lt; 2^6. 故容量为2^6=16 🔹 HashTable:增加一倍,再+1.初始值为11 3.1.5 null值的处理 🔹 HashMap:key和value都支持null值，key仍不可重复🔹 HashTable:抛NullPointerException 3.2 HashMap 与 HashSet 3.2.1 底层实现 HashSet底层与HashMap一致，其内部调用了HashMap的方法。 1234567891011//HashSet 中的代码：其中的方法实现是通过HashMap代理来实现private transient HashMap&lt;E,Object&gt; map;private static final Object PRESENT = new Object();public int size() &#123; return map.size();&#125;public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; 3.2.2 对Hashcode的计算 🔹 HashMap：根据key和value进行运算🔹 HashSet：没有重写HashCode方法，value值以空对象代替。 123456789101112131415161718192021//该节点类为HashMap中内部类static class Node&lt;K, V&gt; implements Entry&lt;K, V&gt; &#123; //key和value的地址进行异或运算（不同则1，相同则0） public final int hashCode() &#123; return Objects.hashCode(this.key) ^ Objects.hashCode(this.value); &#125; public final boolean equals(Object var1) &#123; if (var1 == this) &#123; return true; &#125; else &#123; if (var1 instanceof Entry) &#123; Entry var2 = (Entry)var1; if (Objects.equals(this.key, var2.getKey()) &amp;&amp; Objects.equals(this.value, var2.getValue())) &#123; return true; &#125; &#125; return false; &#125; &#125;&#125; 📁内容补充：hashcode() 与 equals() 🔹 Object中的hashcode()，是关于其该对象实例的内存地址。🔹 Map中，hashcode 相同，equals不一定相等，表示在同一个散列数据结构（链表）。equal相等，hashcode一定相等。🔹 由于hashcode存在冲突，故需要使用equals进行判断。 3.3 ConcurrentHashMap 与 HashTable 两者都是线程安全。HashTable几乎所有方法都添加了同步，效率低。JDK1.7的ConcurrentHashMap则是来取代HashTable。 3.3.1 底层实现 🔹 ConcurrentHashMap：同HashMap🔹 HashTable：数组+链表 3.3.2 线程安全的策略 🔹 ConcurrentHashMap：使用“分段式锁”。&emsp;每一段数据分别加锁。而且加的锁是ReentrantLock可重入锁。&emsp;👉图片来源 🔹 HashTable：大部分方法添加了同步。如put/get方法添加了Synchronzed。&emsp;效率很低，近似整个容器对象添加了锁。&emsp;👉图片来源","categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"个人笔记/Java","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/"},{"name":"基础","slug":"个人笔记/Java/基础","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/%E5%9F%BA%E7%A1%80/"},{"name":"容器","slug":"个人笔记/Java/基础/容器","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/%E5%9F%BA%E7%A1%80/%E5%AE%B9%E5%99%A8/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jianxilin.github.io/tags/Java/"},{"name":"Java容器","slug":"Java容器","permalink":"https://jianxilin.github.io/tags/Java%E5%AE%B9%E5%99%A8/"}]},{"title":"[总结]Git的基本使用","slug":"总结-Git的基本使用","date":"2020-05-13T03:48:49.000Z","updated":"2020-05-13T06:49:27.859Z","comments":true,"path":"2020/05/13/总结-Git的基本使用/","link":"","permalink":"https://jianxilin.github.io/2020/05/13/%E6%80%BB%E7%BB%93-Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"Git作为一个版本控制的工具,在我们学习过程中是必不可少的。不仅是Git仓库GitHub、Gitee，还是在编辑器VSCode，Git在管理文件、控制文件版本、回退文件、多人协作、并发开发等有着重要的地位。以下将对Git的基本使用继续总结、记录。","text":"Git作为一个版本控制的工具,在我们学习过程中是必不可少的。不仅是Git仓库GitHub、Gitee，还是在编辑器VSCode，Git在管理文件、控制文件版本、回退文件、多人协作、并发开发等有着重要的地位。以下将对Git的基本使用继续总结、记录。 1. Git与SVN的简单区分 🔹 实现方式上&emsp;SVN : 集中版本控制。SVN所控制的所有版本内容存储在单一服务器上，本地用户在未联网的情况下，只能看到所同步的版本内容。&emsp;Git : 分布式版本控制。不同于SVN，本地的每个本地用户都能获取到所有版本内容，且Commit操作是在用户本地进，之后再push到远端仓库。&emsp;Git相比SVN，空间成本增加了，且安全性也有所下降，但也减少了数据损失而无法恢复的风险。 🔹 克隆多分支项目&emsp;SVN克隆所有分支的内容&emsp;Git克隆master分支,其它分支只获取相关元素，节省了时间。 2. Git的基本使用 2.1 配置信息 🔹 获取配置信息： 123456// 获取全部配置信息git config -l// 获取系统级别配置信息，对应 \\git主目录\\etc\\gitconfiggit config --system -l// 获取用户(全局)级别的配置信息，对应 \\user\\Administrator\\.gitconfiggit config --global -l 🔹 配置全局的用户信息 12git config --global user.name \"用户名\"git config --global user.email 邮箱 2.2 操作仓库内容 🔹 初始化本地仓库 1git init 🔹 添加到缓存并提交到本地仓库 12git add . git commit -m \"注释\\提交的说明信息\" 🔹 提交到远程仓库 1git push 地址 master 🔹 克隆远程仓库 \\ 获取远程代码 12git clone 地址 分支(eg:master)git pull 地址 分支(eg:master) 🔹 查看本地文件状态 1git status 3.HEAD HEAD 指当前分支的最近一次提交head 指commit对象 head 包含 HEAD 🔹 占位符 ~ 与 ^ ~ ： 表示祖先commit&emsp;&emsp;eg : HEAD~ = HEAD~1 = 前一代commit（父辈）&emsp;&emsp;&emsp;HEAD~~ = HEAD~2 = 前两代commit（爷爷辈）^ : 单个父辈时，与 ~ 基本一致。&emsp;&emsp;多个父辈时，^ = ^1 = 第一个父辈 🔹 案例 1234567891011121314151617181920G H I J \\ / \\ / D E F \\ | / \\ \\ | / | \\|/ | B C \\ / \\ / AA = = A^0B = A^ = A^1 = A~1C = A^2 = A^2D = A^^ = A^1^1 = A~2E = B^2 = A^^2F = B^3 = A^^3G = A^^^ = A^1^1^1 = A~3H = D^2 = B^^2 = A^^^2 = A~2^2I = F^ = B^3^ = A^^3^J = F^2 = B^3^2 = A^^3^2 👉此内容参考来源 4. 信息查看 🔹 获取本地文件状态 1git status 🔹 获取commit历史信息 12git loggit log --oneline 🔹 查看当前索引(暂存区) 1git ls-files -s 🔹 显示了 HEAD 快照实际的目录列表 1git cat-file -p HEAD 🔹 查看HEAD的当前指向 1cat .git/HEAD 🔹 查看HEAD各个祖先 1git rev-parse HEAD~ //前一个祖先(父辈) 5. 撤销操作 🔹 git checkout [不写|HEAD] &lt;file&gt; //旧版 🔹 git restore [不写|–staged] &lt;file&gt; //新版 🔹 git reset [–hard|soft|mixed(默认)|merge|keep] [commit|HEAD](1) –soft : 回退到暂存区状态(2) –mixed : 回退到本地状态（本地修改的内容存在）(3) –hard : 回退到某次提交，清除所有历史状态，包括本地文件内容。 🔹 git revert HEAD^ 重新提交，保留历史记录 git reset不保留历史记录 🔹 重写最后一次commit 1git commit --amend -m 6. 冲突解决 🔹 提交时，发生冲突 执行git pull，发生冲突后，git会将两个版本的内容合并在一起。解决：先git status，查找发生冲突的文件，自行修改冲突内容后再提交，pull 🔹 回退commit，发生冲突 执行revert HEAD^，发生冲突。解决：同样查看冲突、修改冲突后，执行git revert –continue。 7. Git的分支处理 🔹 常用命令 12345678910111213141516171819202122232425# 列出所有本地分支git branch# 列出所有远程分支git branch -r# 新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支git checkout -b [branch]# 切换分支git checkout [branch]# 合并指定分支到当前分支$ git merge [branch]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 👉此内容来源 参考文章：狂神说 聊Git📘CSDN 奋飛 Git Pro深入浅出（二）📘","categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"name":"工具","slug":"个人笔记/工具","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7/"},{"name":"版本控制","slug":"个人笔记/工具/版本控制","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"Git","slug":"个人笔记/工具/版本控制/Git","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/"}],"tags":[{"name":"版本控制","slug":"版本控制","permalink":"https://jianxilin.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"Git","slug":"Git","permalink":"https://jianxilin.github.io/tags/Git/"}]},{"title":"[总结]CSS样式失效的原因","slug":"总结-CSS样式失效的原因","date":"2020-05-11T06:49:33.000Z","updated":"2020-05-11T08:50:02.318Z","comments":true,"path":"2020/05/11/总结-CSS样式失效的原因/","link":"","permalink":"https://jianxilin.github.io/2020/05/11/%E6%80%BB%E7%BB%93-CSS%E6%A0%B7%E5%BC%8F%E5%A4%B1%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0/","excerpt":"CSS样式生效，需要正确的语法，并且其样式内容不被覆盖。以下先总结三点原因（后续再补充）：🔹 错误使用单行注释🔹 CSS选择器优先级较低🔹 Chrome浏览器存在CSS文件缓存","text":"CSS样式生效，需要正确的语法，并且其样式内容不被覆盖。以下先总结三点原因（后续再补充）：🔹 错误使用单行注释🔹 CSS选择器优先级较低🔹 Chrome浏览器存在CSS文件缓存 1. 在外部CSS中不能使用单行注释 在CSS选择器上使用单行注释，将导致该注释下的这个CSS选择器里面的内容失效。如下代码所示,“.post-readmore__link{}”将失效,“.post-readmore__link:hover{}”有效，不会受到影响。 1234567//readmore button （第一个CSS选择器无效）.post-readmore__link&#123; background-color: #27ae60;&#125;.post-readmore__link:hover&#123; background-color: #1f7f47;&#125; 而单行注释添加在CSS样式内，该CSS仍有效 123.post-readmore__link&#123; background-color: #27ae60; //green （有效）&#125; 若需要使用注释，可使用多行注释。如下： 1234/* readmore button */.post-readmore__link&#123; background-color: #27ae60; //green （有效）&#125; 2. CSS选择器优先级低于原有的CSS选择器 2.1. 当多个CSS选择器选择目标相同时 🔹 级别相同，后加载的CSS选择器覆盖前CSS选择器中相同的样式。🔹 级别不同，高级别CSS选择器覆盖低级别CSS选择器中相同的样式。 2.2. 级别判断 🔹 内嵌式CSS级别高于外部CSS，可视为最高级别。 🔹 #ID &gt; .Class、属性选择器([type=”button”])和伪类(:hover) &gt; 标签类型和伪元素(::after)级别计算案例：图片内容来源：MDN Web Docs 🔹 使用!important覆盖任何样式声明 123.post-readmore__link&#123; background-color: #27ae60 !important;&#125; 对于都添加！important的样式，则再由其选择器优先级来判断。 3.chrome浏览器存在缓存 🔹 原因:&emsp;&emsp;chrome浏览器为了提高加载效率，缓存了JS、CSS文件，故修改后的文件无法立即生效。 🔹 解决方法：方式一：来回切换开启缓存来重置缓存内容（不一定有效）。&emsp;&emsp;F12打开开发者工具，进入Network，在Disable cache前打勾✔，刷新页面。再把Disable cache关闭，取消✔，再次刷新页面。 方式二：来回切换开启缓存来重置缓存内容&emsp;&emsp;F12打开开发者工具，然后在浏览器的刷新按钮右击，选择“清空缓存并硬性重新加载”","categories":[{"name":"踩坑记录","slug":"踩坑记录","permalink":"https://jianxilin.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"},{"name":"前端","slug":"踩坑记录/前端","permalink":"https://jianxilin.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"踩坑记录/前端/CSS","permalink":"https://jianxilin.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://jianxilin.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"CSS","permalink":"https://jianxilin.github.io/tags/CSS/"}]},{"title":"个人博客[2]——美化","slug":"个人博客-2-——美化","date":"2020-05-11T06:46:50.000Z","updated":"2020-05-11T06:56:49.141Z","comments":true,"path":"2020/05/11/个人博客-2-——美化/","link":"","permalink":"https://jianxilin.github.io/2020/05/11/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-2-%E2%80%94%E2%80%94%E7%BE%8E%E5%8C%96/","excerpt":"环境要求：node.js 和 npm基于 Hexo博客框架基于 Hexo主题stun 美化内容以下：🔹 主题设置🔹 博客主题样式自定义🔹 博客文章样式自定义","text":"环境要求：node.js 和 npm基于 Hexo博客框架基于 Hexo主题stun 美化内容以下：🔹 主题设置🔹 博客主题样式自定义🔹 博客文章样式自定义 效果图： 👉Hexo官方地址 👉Hexo-theme-stun官方地址 1. 修改主题 1.1. 下载主题(stun) git clone https://github.com/liuyib/hexo-theme-stun.git themes/stun 1.2. 配置主题 修改_config.yml 123#Extensions...theme: yilia 1.3. Hexo重设与发布 清除 hexo clean 创建 hexo g 启动 hexo s 推到远端 hexo d 2. 基本样式修改 主题的相关设置详见官方文档📗 可修改Hexo主路径下的_config.yml,将生效于所有主题。也可修改hexo/theme/stun下的_config.xml,将只生效于stun主题。 2.1. 修改博客图标等图片 🔹 方式一：覆盖原图像 在Hexo主路径下的\\themes\\stun\\source\\images\\icons中，使用相同大小的图片覆盖。之后查看stun下的_config.xml是否开启对应的功能。 🔹 方式二：自定义路径 在_config.xml相应的配置下，设置图片路径为自定义图片路径（Hexo下的路径、图床上的路径） 2.2. 修改网页样式 🔹 修改文章样式 将CSS样式添加到stun主题的路径下的\\source\\css_custom\\index.styl文件内即可。内容如下： 1234567891011121314151617// Custom styles by yourself.// You should always modify the style here, not in the source code.// Otherwise, when the theme is updated, the code you modified will be overwritten.body &#123; // modify your style here // eg: background-color: blue; h1 &#123; text-align: center; &#125; h1, h2&#123; color: #4CAF50; &#125; ...&#125; 🔹 修改博客样式 （1）在stun主题的路径下的\\source\\css创建文件夹，自定义名称，名称前需带”_”，例如：_myCss。在该创建的文件夹下放置个人的CSS文件。（2）配置CSS文件。在stun\\source\\css\\index.styl文件内添加以下内容：@import ‘个人的CSS文件全路径’如下： 12345678910111213141516// Variables Layer// --------------------------------------------------@import './_variables/index.styl';// Mixins Layer// --------------------------------------------------@import './_mixins/index.styl';// Common Layer// --------------------------------------------------@import './_common/index.styl';// Custom Layer// --------------------------------------------------@import './_custom/index.styl';// MyCSS// --------------------------------------------------@import './_myCss/myCss.css';","categories":[{"name":"个人博客","slug":"个人博客","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"个人博客","slug":"个人博客","permalink":"https://jianxilin.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}]},{"title":"个人博客[3]——写作","slug":"个人博客-3-——写作","date":"2020-05-11T06:44:24.000Z","updated":"2020-05-11T06:55:24.757Z","comments":true,"path":"2020/05/11/个人博客-3-——写作/","link":"","permalink":"https://jianxilin.github.io/2020/05/11/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-3-%E2%80%94%E2%80%94%E5%86%99%E4%BD%9C/","excerpt":"环境要求：node.js 和 npm基于 Hexo博客框架基于 Hexo主题stun 本文内容包含：🔹 创建、修改、删除文章🔹 创建分类、标签页面🔹 在stun主题内开启分页和标签页面","text":"环境要求：node.js 和 npm基于 Hexo博客框架基于 Hexo主题stun 本文内容包含：🔹 创建、修改、删除文章🔹 创建分类、标签页面🔹 在stun主题内开启分页和标签页面 1. 创建 具体操作见官方文档📗 1.1. 创建文章 12hexo n \"文章名称\"hexo c &amp; hexo g 1.2. 创建分类、标签页面（即创建页面） 🔹 创建分类页面 在Hexo主路径下，执行以下命令 1hexo new page categories 在文章编写时，在文章顶部的Front-matter添加分类信息： 1234categories： - 分类名称 - 下一级分类名称 - [同级分类名称...] 🔹 创建标签页面 与创建分页页面相同，将categories改为tags即可。不同的是，Front-matter中的tags没有分级。 例子： 12345678910---title: '个人博客[1]——搭建'date: 2020-05-10 17:39:21tags: 个人博客categories: - 个人博客photos: - url--- 🔹 在stun主题内开启分页和标签页面 在stun主路径下的_config.yml配置文件的menu节点下添加页面配置信息，如下 1234567menu: home: / || fas fa-home archives: /archives/ || fas fa-folder-open categories: /categories/ || fas fa-layer-group tags: /tags/ || fas fa-tags # You can add a secondary menu like follow. # xxx1: javascript:; || fa(s|r|l|d|b) fa-xxx 效果图： 2.修改 2.1. 修改文章名称 &emsp;&emsp;Hexo未提供修改文件名称的命令。 🔹 解决方法： &emsp;&emsp;最简单的方式就是重新创建该文章，将要修改文章迁移过去。单独修改文章名称和修改文章内的Title标签是无效的。&emsp;&emsp;也可使用hexo-console-renamer插件，后续使用后再来补充。 2.2 删除文章 &emsp;&emsp;同样的，Hexo未提供删除文章的命令。 🔹 解决方法： &emsp;&emsp;在Hexo主路径下的\\source_posts文件夹内，手动删除文章文件，之后再重新创建博客内容，即运行以下命令 1hexo c &amp; hexo g","categories":[{"name":"个人博客","slug":"个人博客","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"个人博客","slug":"个人博客","permalink":"https://jianxilin.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}]},{"title":"个人博客[1]——搭建","slug":"个人博客-1-——搭建","date":"2020-05-10T09:39:21.000Z","updated":"2020-05-11T04:32:41.744Z","comments":true,"path":"2020/05/10/个人博客-1-——搭建/","link":"","permalink":"https://jianxilin.github.io/2020/05/10/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-1-%E2%80%94%E2%80%94%E6%90%AD%E5%BB%BA/","excerpt":"环境要求：node.js 和 npm基于 Hexo博客框架 👉Hexo官方地址","text":"环境要求：node.js 和 npm基于 Hexo博客框架 👉Hexo官方地址 1. 配置环境 安装node.js和npm修改npm的镜像为阿里镜像，即按照cnpm 安装cnpm cmd命令： &emsp;&emsp;npm install -g cnpm –registry=https://registry.npm.taobao.org 安装测试： &emsp;&emsp;cnpm -v 2. 安装Hexo框架 2.1. 安装：cnpm install -g hero-cli 2.2. 验证安装：hexo -v 3. 初始化Hexo博客 3.1. 初始化hexo项目：hexo init 3.2. 启动项目：hexo s 4. 添加第一篇文章 👉Hexo官方:写作 创建新文章：hexo n 文件名 清理：hexo clean 生成文章：hexo g 重启：hexo s 5. 部署到GitHub上 5.1. 创建git仓库,名称为 “git账号名.github.io”5.2. 安装github部署插件。 在本地博客路径下，运行 cnpm install –save hexo-deployer-git 5.3. 添加仓库信息 修改_config.yml。 在#deployment节点下，内容如下： ==冒号后需 + 空格== 12345#deploymentdeploy: type: git repo: 仓库地址 branch: master5.4. 部署到远端 hexo d","categories":[{"name":"个人博客","slug":"个人博客","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"个人博客","slug":"个人博客","permalink":"https://jianxilin.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}]}],"categories":[{"name":"java","slug":"java","permalink":"https://jianxilin.github.io/categories/java/"},{"name":"validation","slug":"java/validation","permalink":"https://jianxilin.github.io/categories/java/validation/"},{"name":"前端","slug":"前端","permalink":"https://jianxilin.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"axios","slug":"前端/axios","permalink":"https://jianxilin.github.io/categories/%E5%89%8D%E7%AB%AF/axios/"},{"name":"个人笔记","slug":"个人笔记","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"个人笔记/Java","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/"},{"name":"基础","slug":"个人笔记/Java/基础","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/%E5%9F%BA%E7%A1%80/"},{"name":"容器","slug":"个人笔记/Java/基础/容器","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/%E5%9F%BA%E7%A1%80/%E5%AE%B9%E5%99%A8/"},{"name":"工具","slug":"个人笔记/工具","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7/"},{"name":"版本控制","slug":"个人笔记/工具/版本控制","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"Git","slug":"个人笔记/工具/版本控制/Git","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/"},{"name":"踩坑记录","slug":"踩坑记录","permalink":"https://jianxilin.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"},{"name":"前端","slug":"踩坑记录/前端","permalink":"https://jianxilin.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"踩坑记录/前端/CSS","permalink":"https://jianxilin.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/%E5%89%8D%E7%AB%AF/CSS/"},{"name":"个人博客","slug":"个人博客","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"java vaildation 数据校验","slug":"java-vaildation-数据校验","permalink":"https://jianxilin.github.io/tags/java-vaildation-%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/"},{"name":"前端 axios","slug":"前端-axios","permalink":"https://jianxilin.github.io/tags/%E5%89%8D%E7%AB%AF-axios/"},{"name":"Java","slug":"Java","permalink":"https://jianxilin.github.io/tags/Java/"},{"name":"Java容器","slug":"Java容器","permalink":"https://jianxilin.github.io/tags/Java%E5%AE%B9%E5%99%A8/"},{"name":"版本控制","slug":"版本控制","permalink":"https://jianxilin.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"Git","slug":"Git","permalink":"https://jianxilin.github.io/tags/Git/"},{"name":"前端","slug":"前端","permalink":"https://jianxilin.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"CSS","permalink":"https://jianxilin.github.io/tags/CSS/"},{"name":"个人博客","slug":"个人博客","permalink":"https://jianxilin.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}]}