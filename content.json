{"meta":{"title":"Jianxi's Blog","subtitle":"Learn to code and share","description":"","author":"JianxiLin","url":"https://jianxilin.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-05-10T16:01:52.000Z","updated":"2020-05-10T16:06:36.161Z","comments":true,"path":"categories/index.html","permalink":"https://jianxilin.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-10T16:02:27.000Z","updated":"2020-05-10T16:06:09.613Z","comments":true,"path":"tags/index.html","permalink":"https://jianxilin.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"redis——数据结构（未完成）","slug":"redis——数据结构（未完成）","date":"2020-06-18T15:25:17.000Z","updated":"2020-06-18T15:35:02.888Z","comments":true,"path":"2020/06/18/redis——数据结构（未完成）/","link":"","permalink":"https://jianxilin.github.io/2020/06/18/redis%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E6%9C%AA%E5%AE%8C%E6%88%90%EF%BC%89/","excerpt":"1. String 1.1. 底层结构 SDS（simpled dynamic string）简单动态字符串。","text":"1. String 1.1. 底层结构 SDS（simpled dynamic string）简单动态字符串。 buf：为字符数组，记录string内容free：记录可用的空间大小len：记录已用的空间大小（不包含’\\0’） 1.2. SDS特点 1️⃣ 获取字符长度方法的复杂度为O(1) &emsp;由于SDS中记录了字符串已使用的长度，不需要通过’\\0’来计算长度，所以可快速获取，且该长度并不记录上’\\0’。但是字符数组中仍保留了’\\0’,其目的是为了可重用C语言中的相关函数。 2️⃣ 杜绝缓冲区溢出 &emsp;C语言在为字符串拼接内容时，需手动为字符串分配相应的空间，才能保证拼接后的内容不溢出，这就导致了存在缓冲区溢出的风险。&emsp;SDS在拼接字符串时，会先通过free来判断空闲的空间是否足够存放新增的内容，若不够则直接自动扩张，再继续拼接。 💬 SDS内存空间扩展策略 🔹 空间预分配 内容扩展次数为n时，空间重分配次数最大为n。 &emsp;当已使用的内容 &lt;1MB,则预先扩展len个内存空间，即free = len，其总空间free+len+1&emsp;当已使用的内容 &gt;= 1MB,分配1MB空间,其总空间为len+1MB+1byte 🔹 空间懒性释放 &emsp;当字符串内容删减后，空闲的空间并不会释放。可减少空间因字符串内容添加而进行空间重分配的次数。&emsp;同时，为了防止空闲空间过多导致内存空间浪费。redis中提供相应的方法用于释放内存空间。 sdsfree 释放空间 sdsclear 清除空间内容，不释放空间。复杂度为O(1) 3️⃣ 二进制安全 &emsp;在c语言中，由于以’\\0’作为字符串结束的标志，所以不能存储空字符，除了字符串末尾。为此，c语言中的字符串写入时需进行相应的编码，读取时也就需要与其编码一致。&emsp;而在sds中，由于是以len的值来鉴定字符串的结束，所以sds在写入时，将以二进制的方式来写入，不进行相应的处理操作。写入什么，读取到的就是什么。 2. list 非环状的双向链表 2.1. 特点 🔹 双向链表🔹 非环状，头结点的head和尾结点的next指向null🔹 记录链表长度🔹 存储类型为void*，可存储不同类型的数据 3. hashmap 哈希函数+链表 3.1. 字典结构 type用于实现字典的多态化，可指定不同类型字典相应的特定函数。 void* privdata为type指定函数的参数 ht[2]:存储了两个哈希表的地址。 rehash：用于辅助rehash操作。默认为-1 3.2. 特点 1️⃣ 以链表方式处理哈希冲突 redis中的字典在处理哈希值冲突时，是将hash值冲突的内容以链表的形式连接到一起，作为一个整体来进行存储。 2️⃣ 渐进式的rehash &emsp;由于redis中的字典以链表来存储hash冲突的值，所以在极端情况下，字典的元素查找复杂度将从O（1）退化为O（n）.&emsp;为此，字典需要进行rehash操作。在字典中，通过一个双倍的hashlist空间来实现rehash，分别为ht0和ht1。h1充当类似中间者的角色，h0的值rehash后，存储到h1中。当h0的内容为空时，则使用ht1来取代ht0。&emsp;但由于同时对ht0的全部内容进行rehash，需消耗较长的时间，且期间将无法进行字典的其它操作。故演变为渐进式的rehash。&emsp;渐进式rehash即在每次字典操作，对ht[0]其中一行进行rehash。对于需要进行rehash的行数则由rehash值决定。 4. zset 4.1. 底层结构 跳表 》》》》》》 待补充","categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"个人笔记/数据库","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"NoSQL","slug":"个人笔记/数据库/NoSQL","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/"},{"name":"Redis","slug":"个人笔记/数据库/NoSQL/Redis","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://jianxilin.github.io/tags/Redis/"},{"name":"NoSQL","slug":"NoSQL","permalink":"https://jianxilin.github.io/tags/NoSQL/"}]},{"title":"redis——基本命令","slug":"redis——基本命令","date":"2020-06-18T15:15:33.000Z","updated":"2020-06-18T15:32:09.683Z","comments":true,"path":"2020/06/18/redis——基本命令/","link":"","permalink":"https://jianxilin.github.io/2020/06/18/redis%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/","excerpt":"1、Redis的相关linux命令 window：进入Redis目录，启动Redis，连接Redis。 linux：开启Redis服务：redis-server redis.conf文件 连接Redis命令：redis-cli -h 127.0.0.1 -p 6379","text":"1、Redis的相关linux命令 window：进入Redis目录，启动Redis，连接Redis。 linux：开启Redis服务：redis-server redis.conf文件 连接Redis命令：redis-cli -h 127.0.0.1 -p 6379 退出：shutdown 再exit 查看Redis线程是否启动 方法1：ps -ef|grep redis 方法2：lsof -i ：6379 测试连接：ping 2、常用命令 keys pattern（？(1)、*(0-~)、[范围始-范围末]、\\）——查询key Exists key——判断key是否存在 del key[key…]——删除key，返回删除数量 move key DB——移动key到某号库 Type key——获取类型 DBSize——查看key数量 flushDB 、 flushAll——清除本仓库、清除所有库 help @指令——查询帮助文档 3、数据类型 五大数据类型：String、Hash、List、Set、Sorted set 3.1 string get \\ set key——获取\\设置值已存在则覆盖 mset key value[key value…]——设置多个值 mget key[key…]——获取多个值 append key value ——后追加，返回总长度 strlen key——获取长度 incr key——自增设置值，从0开始，1为递增 incrby key num ——num为递增值 decr、decrby ——自减、不能为负值 getRange key start end ——获取范围内的值 (0到-1则是全部) setRange key start value… ——设置某范围的值 setex key timeout秒 value ——设置过期时间 set with expire setnx key value ——设置值 set if not exist若已存在则不修改 msetnx 多个设值若有一个不存在则无法设置 3.2 （重点） hash k-v，v中也为k-v，以下region_key表示hash的key，key表示hash的value中的key （重点）设置、获取值: hset region_key key value ——设置域及其值 hmset region_key key value[key value…] hget region_key key ——获取对应域的值 hmget region_key key[key…] hgetall region_key ——获取对应域的所有的key、value （重点）获取所有的key或者value hkeys region_key ——获取hash中所有的key hvals region_key ——获取hash中所有的value hexists region_key hdel、hlen region_key 增长值 hincrby region_key key 增值 hincrbyfloat region_key key 增值 hsetnx region_key key value ——如果不存在则可添加（返回0/1，0已存在，1不存在） 3.3 list（双向链表） lpush key value[value…] ——左添加值 rpush key value[value…] lpop key ——左删除一个值 rpop key lindex key index ——获取指定值 （可用负数。-0效果同0） llen ——获取长度 lrange key start end ——获取片段（start、end可不存在，只是划范围） lrem key count value ——删除n个值（count = 0/全、 &gt; 0/左、&lt; 0/右 ） ltrim key startIndex endIndex ——截取value中某范围的值，重新赋给value（不能使用负数） rpoplpush key1 key2 ——将key1中的尾部元素添加到key2值的0位置。 lset key index value ——设置某个位置的值 linsert key before/after value newValue ——在某个值前面/后面插入一个值（只对添加一个值） 3.4 set sadd key value[value…] ——添加若有已存在的，不报错，只加不存在的值 srem key value[value…] ——删除 smembers key —— 获取所有值 sismember key value —— 是否存在该值 scard key —— 获取值的数量，获取长度 srandmember key 整数数量 ——随机获取set中几个值 整数:无重复值.负数:有可能存在重复值 spop key ——随机出栈 smove key1 key2 key1中的值 ——将key1中某个值移动到key2中 数学集合: 1.差集 sdiff key1 key2 （在key1中）2.交集 sinter3.并集 sunion 3.5 zset——sorted set （散列表） set的基础上，在value值中添加一个score值（浮点型数据）。set：key v1 v2 v3…zset： key scoure1 v1 scoure2 v2… zadd key score value[score value…] —— 设置值(值唯一，若值存在则修改score，未存在返回1，存在返回0) zrem key value ——删除值 zrange（/zrevrange） key start end （withscores）—— 获取(/逆向)片段值（含key） zrangeByScore（/zrev…） key start（/end） end（/start）—— 获取以Scoure（/逆向）排序片段值 zRemrangeByRank key startNum endNum ——删除片段（以rank排名） zRemrangeByScore key startScore endScore——删除片段（以Score排名）(Score 表示不包含该scorelimit start numwithscores zcard key ——获取数量，scoure与value为一个整体 zcount key scoureStart scoureEnd ——获取某Scoure区间的数量 zrank（/zrevrank） key value ——获取（/逆向）下标值 zscore key value ——获取对应的scoure值 4、生存时间（TTL） expire key num ——设置生存时间（秒） pexpire key num ——设置生存时间（毫秒） TTL key —— 查看生成时间-1：表示永不过期 2：表示已过期（即已删除） persist key —— 删除生存时间","categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"个人笔记/数据库","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"NoSQL","slug":"个人笔记/数据库/NoSQL","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/"},{"name":"Redis","slug":"个人笔记/数据库/NoSQL/Redis","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://jianxilin.github.io/tags/Redis/"},{"name":"NoSQL","slug":"NoSQL","permalink":"https://jianxilin.github.io/tags/NoSQL/"}]},{"title":"docker——基本命令","slug":"docker——基本命令","date":"2020-06-18T15:06:42.000Z","updated":"2020-06-18T15:33:04.152Z","comments":true,"path":"2020/06/18/docker——基本命令/","link":"","permalink":"https://jianxilin.github.io/2020/06/18/docker%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/","excerpt":"记录docker的基本命令，包括镜像、容器相关命令以及其它常用命令。","text":"记录docker的基本命令，包括镜像、容器相关命令以及其它常用命令。 补充：启动docker : systemctl start dockerdockerHub : https://hub.docker.com/ 1. 信息 🔹 查看版本 docker version 🔹 查看信息 docker info 🔹 帮助信息 docker –help 🔹 状态信息 docker stats 容器id 2. 镜像 🔹 查看所有 docker images -a : 显示所有 -q : 只显示id -f : 过滤1docker images -aq 🔹 搜索 docker search 关键字 --filter : 过滤1docker search mysql --filter=STARS=3000 🔹 下载 docker pull 镜像名称[:tag] 1docker pull mysql:5.7 描述信息： 123456789101112//分层下载，已存在则不重复下载5.7: Pulling from library/mysql8559a31e96f4: Already existsd51ce1c2e575: Already exists....f7a5433ce20d: Pull complete3dcd2a278b4a: Pull complete//签名Digest: sha256:32f9d9a069f7a735e28fd44ea....Status: Downloaded newer image for mysql:5.7//实际地址docker.io/library/mysql:5.7 🔹 删除 docker rmi [镜像名称…|ID…] -f,--Force : 强制删除123docker rmi -f 9cfcce23593a# 删除所有镜像docker rmi -f $(docker images -aq) 3. 容器 🔹 启动 docker run [参数] 镜像ID|镜像名称[:TAG] --name=&quot;&quot; : 容器名称 -d : 以后台的方式启动 -it : 交互方式运行（启动容器后进入容器操作） -p : 指定端口 -p ip:主机端口:容器端口 -p 主机端口:容器端口 -p 容器端口 -P : 随机端口123docker run -it centos /bin/bash# --rm 用于测试，关闭即删除，docker ps 无记录docker run -it --rm centos /bin/bash 注意：当centos镜像没有运行内容时，容器即使是后台启动，也会被停止。netty也是一样。 🔹 退出|停止 exit该命令将退出容器界面同时停止容器 快捷键：Ctrl+p+q 仅退出容器不停止容器 🔹 查看 docker ps -a : 查看所有（包含历史启动） -n=? : 显示最近的容器,eg:-n=1 -q : 只显示编号1docker ps -a 🔹 删除 docker rm -f : 强制删除12345//删除指定的容器docker rm 容器id//删除所有容器docker rm -f $(docker ps -aq)docker ps -aq | xargs docker rm -f 🔹 启动、重启、停止、杀死 docker start 容器iddocker stop 容器iddocker restart 容器iddocker kill 容器id 4. 常用命令 🔹 提交 docker commit 容器id 目标镜像名[:TAG] -m ：提交说明信息 -a : 作者名称123456docker commit -m \"update tomcat\" -a \"xi\" e4e7c5efc101 my_tomcat:1.0//查询提交结果[root@iZuf6505h9bgsfqqmhomj6Z /]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEmy_tomcat 1.0 398a9379c1db 54 seconds ago 652MB 🔹 查看日志 docker logs 容器id -t : 时间戳 -f : --tail : 显示的数量1docker logs -tf --tail 10 测试： 123docker run -d centos /bin/sh -c \"while true;do echo demo_docker;sleep 1;done\"docker logs -tf --tail 10 99a271fc5dc5 🔹 查看进程信息 docker top 容器id 1docker top 99a271fc5dc5 🔹 查看容器基本信息–元数据 docker inspect 容器id 1docker inspect 99a271fc5dc5 🔹 进入正在运行的容器 方式一：docker exec 容器id -it 交互式运行1docker exec -it 99a271fc5dc5 /bin/bash 方式二：docker attach 容器id 1docker attach 99a271fc5dc5 exec : 开启新终端attach : 进入正在执行的终端 🔹 copy文件——从容器到主机 docker cp 容器id:容器内路径 主机路径 12// 将容器中/test.c 文件复制到 主机的/test.cdocker cp 48948a693704:test.c /test.c 🔹 给镜像添加tag docker tag 镜像id 镜像名称:tag","categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"name":"Docker","slug":"个人笔记/Docker","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://jianxilin.github.io/tags/Docker/"}]},{"title":"docker——Dockerfile","slug":"docker——Dockerfile","date":"2020-06-18T15:06:31.000Z","updated":"2020-06-18T15:32:59.370Z","comments":true,"path":"2020/06/18/docker——Dockerfile/","link":"","permalink":"https://jianxilin.github.io/2020/06/18/docker%E2%80%94%E2%80%94Dockerfile/","excerpt":"1. 什么是Dockerfile Dockerfile是docker中用于创建镜像的构建文件。","text":"1. 什么是Dockerfile Dockerfile是docker中用于创建镜像的构建文件。 2. 构建过程 🔹 使用 docker build [参数] 路径来创建 -f : Dockerfile文件 (不指定时.默认为Dockerfile) -t : tag 生成的镜像文件名[:tag]使用Dockerfile来创建镜像时,Dockerfile中的命令逐行运行,且Dockerfile中的每一个命令都作为镜像的一层。 1234567891011121314151617181920212223# 使用Dockerfile创建镜像docker build -f /home/docker-demo-volume/Dockerfile -t xi/centos:1.0 .--------------输出内容（每一条命令为镜像中的一层）-----------------Sending build context to Docker daemon 2.048kBStep 1/4 : FROM centos // 镜像中的一层 ---&gt; 470671670cacStep 2/4 : VOLUME [\"volume01\",\"volume02\"] // 镜像中的一层 ---&gt; Running in 77c7856b6bd7Removing intermediate container 77c7856b6bd7 ---&gt; 2de9fb538af5Step 3/4 : CMD \"==END==\" // 镜像中的一层 ---&gt; Running in 78ae62e1984aRemoving intermediate container 78ae62e1984a ---&gt; 72e2c6602a30Step 4/4 : CMD \"/bin/bash\" // 镜像中的一层 ---&gt; Running in 4a98993afbacRemoving intermediate container 4a98993afbac ---&gt; d00e4595f1aeSuccessfully built d00e4595f1aeSuccessfully tagged xi/centos:1.0---------------------------End-------------------------------- 通过Dockerfile文件可创建1n个镜像, 1n个镜像运行后则组成一个容器 3. 指令 3.1. 常用指令 指令 作用 说明 FROM 指定基础镜像 MAINRAINER 维护者、作者信息 姓名&lt;邮箱&gt; RUN 构建时,所执行的内容 ADD 用于添加其它镜像 ADD tar.gz压缩包 解压路径 WORKDIR 该镜像的工作目录 VOLUME 挂载的目录 EXPOST 端口配置 CMD 启动时,执行的内容 ( 只有最后一个命令生效 )–命令替换 ENTRYPOINT 启动时,所执行的内容( 命令都生效 ) – 命令追加 ONBUILD 在镜像构建后,执行的命令 COPY 将文件复制到该镜像中,类似ADD COPY 文件 镜像内文件 ENV 设置环境变量 ENV KEY VALUE 3.2. 案例 1️⃣ 修改CentOS镜像 docker中CentOS为阉割版,去除了运行所不必要的内容,默认工作目录为根目录.该案例在这基础上,给其添加ifconfig、vim指令和指定工作目录. 12345678910111213141516171819202122232425262728293031# 1. 编写Dockerfilevi Dockerfile_centos--------------------Dockerfile_centos内容-----------------------FROM centos # 指定centos为基础镜像MAINTAINER Jianxi&lt;123456@qq.com&gt; # 指定维护者信息ENV MYPATH /usr/local # 添加环境参数WORKDIR $MYPATH # 指定工作目录 $参数名-获取环境参数RUN yum -y install vim # 镜像创建时,安装vimRUN yum -y install net-tools # 镜像创建时,安装网络操作命令,含ifconfigEXPOSE 80 # 指定该镜像对外开放端口80CMD echo $MYPATH # 镜像启动时,执行该命令,输出MYPATH参数的值CMD echo \"----End-----\"CMD /bin/bash------------------------------End--------------------------------# 2. 创建镜像docker build -f Dockerfile_centos -t mycentos:1.0 .# 3. 测试# 启动镜像docker run -it 3ff53fe7bd05# 检查工作路径pwd # 输出 /usr/local# 检查ifconfig与vim是否存在、可用ifconfig # 可用vim -version # 可用 2️⃣ 创建Tomcat镜像 以centos为基础,配置tomcat以及jdk环境.并且将tomcat项目部署文件夹和日志文件夹挂载到主机上. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# 1.编写Dockerfile_tomcat文件vi Dockerfile_tomcat-----------------------------Dockerfile_tomcat内容-----------------------------FROM centosMAINTAINER xi&lt;123456@qq.com&gt;COPY readme.txt /usr/local/readme.txtADD jdk-8u251-linux-x64.tar.gz /usr/localADD apache-tomcat-8.5.56.tar.gz /usr/localRUN yum -y install vimENV MYPATH /usr/localWORKDIR $MYPATHENV JAVA_HOME /usr/local/jdk1.8.0_251ENV CLASSPATH $JAVA_HOME/lib/dt.jar;$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-8.5.56ENV CATALINA_BASH /usr/local/apache-tomcat-8.5.56ENV PATH $PATH:$JAVA_HOME/bin;$CATALINA_HOME/lib;$CATLINA_HOME/binEXPOSE 8080CMD /usr/local/apache-tomcat-8.5.56/bin/startup.sh \\&amp;&amp; tail -F /usr/local/apache-tomcat-8.5.56/bin/logs/catalina.out --------------------------------------End-----------------------------------# 2. 创建镜像docker build -f Dockerfile_tomcat -t mytomcat:1.0 .# 3. 启动该镜像的容器并挂载目录docker run -d -p 9090:8080 --name xitomcat \\-v /home/docker_demo_volume/tomcat/testproject:/usr/local/apache-tomcat-8.5.56/webapps/test \\-v /home/docker_demo_volume/tomcat/logs:/usr/local/apache-tomcat-8.5.56/logs \\mytomcat:1.0# 4. 测试,访问地址ip:9090 #显示tomcat页面# 5. 在主机被挂载的目录上添加web.xml和index.jsp.# 测试挂载目录是否有效docker exec -it 37c468f8eed9 /bin/bashcd /home/docker_demo_volume/tomcat/testprojectmkdir MEB-INF &amp;&amp; cd MEB-INF &amp;&amp; vim web.xml------------------------------web.xml--------------------------------&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" version=\"2.5\"&gt; ...&lt;/web-app&gt;-------------------------------End-----------------------------------cd ../vim index.jsp------------------------------index.jsp------------------------------&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;docker tomcat&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%= new String(\"Hello!\") %&gt; &lt;/body&gt;&lt;/html&gt;-------------------------------End------------------------------# 6. 测试,访问地址ip:9090/test #显示Hello! 3.3. docker history命令 语法: docker history 镜像ID作用: 查看该镜像创建时,指令执行的历史记录.","categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"name":"Docker","slug":"个人笔记/Docker","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://jianxilin.github.io/tags/Docker/"}]},{"title":"docker——容器数据卷","slug":"docker——容器数据卷","date":"2020-06-18T15:06:19.000Z","updated":"2020-06-18T15:35:22.845Z","comments":true,"path":"2020/06/18/docker——容器数据卷/","link":"","permalink":"https://jianxilin.github.io/2020/06/18/docker%E2%80%94%E2%80%94%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7/","excerpt":"1. 什么是容器数据卷 docker中实现数据持久化的方案。将容器内的文件关联到主机（宿主机）的文件，可实现容器数据持久化与同步操作以及共享数据。","text":"1. 什么是容器数据卷 docker中实现数据持久化的方案。将容器内的文件关联到主机（宿主机）的文件，可实现容器数据持久化与同步操作以及共享数据。 2. 基本使用（实现文件映射–挂载） 2.1. 方式一：使用run命令 -v docker run -it -v 主机目录:容器目录 容器名 将容器目录映射到主机目录后，容器目录将与主机目录进行同步操作，以此实现数据同步。同时主机目录内容修改，容器内容也将发生修改，实现了双向绑定。 12345678910111213141516// 设置容器的映射文件docker run -it -v /home/test:/home centos /bin/bash// 查看映射信息docker inspect 22b642f532bb// inspect中的映射文件配置 \"Mounts\": [ &#123; \"Type\": \"bind\", \"Source\": \"/home/test\", //主机目录 \"Destination\": \"/home\", //docker容器目录 \"Mode\": \"\", \"RW\": true, \"Propagation\": \"rprivate\" &#125; ], 案例（部署mysql） 1234567891011121314151617181920# 1.下载mysqldocker pull mysql:5.7# 2.启动、配置mysql# - 映射端口# - 映射文件# - 设置密码docker run -d -p 3310:3306 \\-v /home/mysql/conf:/etc/mysql/conf.d \\-v /home/mysql/data:/var/lib/mysql \\-e MYSQL_ROOT_PASSWORD=123456 \\--name mysql01 mysql:5.7# 3.测试：# 远程连接并创建数据库# 主机/home。mysql/data也会生成现有的数据库文件# 4.删除docker中的数据库容器，主机中的数据库数据仍会存在docker rm -f fb84a9afc5f3 2.2. 方式二：使用DockerFile 在文件中VOLUME 将指定该容器中将挂载的路径，若路径不存在则会自动创建。若只写容器挂载的路径，则为匿名挂载。 1234567891011121314151617181920# 1.编写Dockerfilevi Dockerfile-----------Dockerfile内容------------FROM centosVOLUME [\"volume01\",\"volume02\"]CMD echo \"--END--\"CMD /bin.bash-----------------End------------------# 2.创建镜像docker build -f /home/docker-demo-volume/dockerfile -t xi/centos:1.0 .# 3.运行镜像并进入docker run -it d00e4595f1ae /bin/bash# 4.查看/volume01与/volume02是否存在ls--------------------显示的内容-------------------------bin dev ...... tmp usr var volume01 volume02------------------------End--------------------------- 3. 数据卷命令 volume docker volume create Create a volume inspect Display detailed information on one or more volumes ls List volumes prune Remove all unused local volumes rm Remove one or more volumes12docker volume lsdocker volume inspect 卷名称 4. 具名挂载和匿名挂载 具名挂载：指定挂载的卷的名称匿名挂载：不指定名称，随机生成卷名称 🔹 使用docker run -v来实现 匿名挂载：-v 容器路径具名挂载：-v 卷名:容器路径指定挂载路径： -v 主机路径:容器路径 设置容器对卷的权限-v 主机路径|卷名 : 容器路径 : ro|rw&emsp;ro : read only&emsp;rw : read and write 1234567891011121314151617181920212223# 1. 匿名挂载nginx文件docker run -d -P --name nginx01 -v /etc/nginx nginx# 查看卷信息docker volume inspect 3780b7c7663441ad015ac22235d7522175c5ceeb02c05433df42b263f8aa4535# 2. 具名挂载nginx文件docker run -d -P --name nginx02 -v nginx-v:/etc/nginx nginx# 查看卷信息docker volume inspect nginx-v[ &#123; \"CreatedAt\": \"2020-06-14T00:38:57+08:00\", \"Driver\": \"local\", \"Labels\": null, \"Mountpoint\": \"/var/lib/docker/volumes/nginx-v/_data\", \"Name\": \"nginx-v\", \"Options\": null, \"Scope\": \"local\" &#125;] 由volume inspect可看出，当不指定主机路径时，默认挂载的目录为/var/lib/docker/volumes/与卷名同名的文件夹/_data 5. 数据卷容器 当某个容器存在文件被多个容器挂载时。该容器则为父容器，也就为数据卷容器。以此实现多个容器之间的数据共享。 🔹 使用 docker run –volumes-from 来实现 –volume-from 挂载的容器名 🔹 案例：&emsp;实现docker01作为数据卷容器，docker02、docker03挂载到其中。 123456789# 开启dockers01docker run -it --name docker01 d00e4595f1ae /bin/bash# 启动docker02，并挂载到dockers01容器docker run -it --name docker02 --volumes-from docker01 /bin/bash# 启动docker03，并挂载到docker01容器docker run -it --name docker03 --volumes-from docker01 /bin/bash 以下图片中的volume01_主机、volume01、_volume01、__volume01文件夹名称都为volume01,这里为了区分,而显示不同名称. volume02也是一样. 当删除数据卷容器后，其子容器挂载在父容器的内容仍存在。当所有容器都删除、关闭后，由于docker01数据卷容器在启动时，挂载了主机，所以卷内容在主机仍有保留。","categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"name":"Docker","slug":"个人笔记/Docker","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://jianxilin.github.io/tags/Docker/"}]},{"title":"SpEL","slug":"SpEL","date":"2020-06-12T03:26:35.000Z","updated":"2020-06-12T07:09:44.237Z","comments":true,"path":"2020/06/12/SpEL/","link":"","permalink":"https://jianxilin.github.io/2020/06/12/SpEL/","excerpt":"1. 简介 SpEL（Spring Expression Language）为Spring中的表达式语言。可用于属性的查询与操作，类似EL表达式。通过@Value与SPEL结合使用，可更灵活地为参数赋值。","text":"1. 简介 SpEL（Spring Expression Language）为Spring中的表达式语言。可用于属性的查询与操作，类似EL表达式。通过@Value与SPEL结合使用，可更灵活地为参数赋值。 2. 语法 2.1. 文字表达式与运算符 支持数值、字符串、日期等类型。运算符支持算术、逻辑、关系运算符。运算符也支持字符符号： lt (&lt;), gt (&gt;), le (&lt;=), ge (&gt;=), eq (==), ne (!=), div (/), mod (%), not (!)。 12345678910111213@Value(\"str1\") // str1private String str;@Value(\"#&#123;str2&#125;\") // str2private String str;@Value(\"#&#123;1+3&#125;\") // 4private Integer num;//其它案例：// 1000.00 - 1e4// \"true and false\" 2.2. 内联列表、内联map 用于对容器相关参数直接赋值。都是用{}来表示。 123456@Value(\"#&#123;&#123;'list_str1','list_str2'&#125;&#125;\")private List&lt;String&gt; list;@Value(\"#&#123;&#123;'name':'name01','password':'password01'&#125;&#125;\")private Map map; 2.3. 三元运算符与Elvis操作符 Elvis 操作符是用于简写判断null值的三元运算符，eg：name!=null ? name : ‘isNULL’ ==&gt; name?:’isNULL’ 123456789@Value(\"#&#123;xi.age&gt;=18?'成年':'未成年'&#125;\")private String str5;@Value(\"#&#123;xi.age==null?xi.age:'isNULL'&#125;\")private String str6;// 等价于@Value(\"#&#123;xi.age?:'isNULL'&#125;\")private String str7; 2.4. 方法调用 在方法调用上，对于普通方法可直接调用，对于静态方法则通过T()来获取静态方法。T(静态类名).function 123456789// 调用String中的方法@Value(\"#&#123;'abc'.substring(2, 3)&#125;\")private String str3;// 调用ioc容器中类的方法@Value(\"#&#123;demoClass.myFun('abcde')&#125;\")private String str4;// 调用静态方法@Value(\"#&#123;T(java.lang.Math).PI&#125;\")private double pi; 2.5. 引用bean 对于bean的获取可以使用@符号来获取ioc容器中内容，也可省略。 1234567891011// 调用ioc容器中类的属性@Value(\"#&#123;@xi.age&#125;\")private String ageStr;// 调用ioc容器中类的属性@Value(\"#&#123;xi.age&#125;\")private String ageStr; // 调用ioc容器中类的方法@Value(\"#&#123;demoClass.myFun('abcde')&#125;\")private Strubg str4; 2.6. 容器过滤与映射 SPEL可通过.?[条件]来对容器进行简单的过滤，?[]将获取符合条件的所有结果。若只需获取第一个结果或最后一个结果，则可使用^[]和$[],其中^[]获取第一个结果，$[]获取最后一个结果 对于容器的映射，则通过![]来实现 1234567891011@startmindmap* 容器** 过滤*** &lt;b&gt;?[条件]&lt;&#x2F;b&gt;*** &lt;b&gt;^[条件]&lt;&#x2F;b&gt;*** &lt;b&gt;$[条件]&lt;&#x2F;b&gt;** 映射*** &lt;b&gt;![条件]&lt;&#x2F;b&gt;@endmindmap 12345@Value(\"#&#123;xi.friends.?[age&lt;10]&#125;\")private List&lt;MyUser&gt; friends_;@Value(\"#&#123;xi.friends.![name]&#125;\") //返回[name...]private List&lt;String&gt; names; 2.7. 正则表达式 通过mathces关键字来实现。 value mathces ‘模板’。 12@Value(\"#&#123;xi.email matches '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9._%+-]+.com'&#125;\") private boolean isEmail; 📘参考：官方文档官方文档-中文版","categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"个人笔记/Java","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/"},{"name":"Spring","slug":"个人笔记/Java/Spring","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/Spring/"},{"name":"SpEL","slug":"个人笔记/Java/Spring/SpEL","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/Spring/SpEL/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jianxilin.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://jianxilin.github.io/tags/Spring/"},{"name":"SpEL","slug":"SpEL","permalink":"https://jianxilin.github.io/tags/SpEL/"}]},{"title":"RESTful API","slug":"RESTful-API","date":"2020-06-07T09:17:22.000Z","updated":"2020-06-07T09:21:35.986Z","comments":true,"path":"2020/06/07/RESTful-API/","link":"","permalink":"https://jianxilin.github.io/2020/06/07/RESTful-API/","excerpt":"REST为一种设计规范通过HTTP来描述操作,URL来定位资源","text":"REST为一种设计规范通过HTTP来描述操作,URL来定位资源 1. HTTP状态码 具体 类别 描述 1XX — 信息性 接受到请求且正在处理 2XX — 成功性 请求处理完毕 200 OK 请求成功 201 Created 创建成功 204 No Content 处理成功，但没返回实体内容，无消息体 3XX — 重定向性 需要进行附加操作来完成操作 300 Multiple Choice 提供多个内容可选择 4XX 4XX 客户端错误 服务端无法处理请求 400 Bad Requset 语义有误，参数有误 404 Not Found 未在服务器上找到相应的资源 405 Method Not Allowed 该请求方法不被允许，例如发送PUT请求到不支持PUT方法的服务器 409 Conflict 请求的资源发生冲突，返回请求时，需提供修改建议（eg : 差异比较） 5XX — 服务端错误 服务端处理请求出错 500 Internal Server Error 服务器不知如何处理该请求 504 Gateway Timeout 获取数据超时 PUT 与 POST：PUT被定义为idempotent（幂等）方法，而POST则不是即重复多个请求，PUT的相应结果是一致的，POST则不是。 header(“HTTP/1.0 409 Conflict”, true);true：已发送相同的header时，后续将与前面的结果一致。false：结果可不一致，即相同请求可并存。 2. RESTful设计规则 Method 操作 状态码 OPTIONS 询问该接口/端点支持哪些方法 200 OK POST Create创建 正常：201；异常：404、409 GET Read读取 正常：200；异常：404 HEAD Read（body为空） 正常：200；异常：404 PUT Replace替换 正常：200；异常：204、404、405 PATCH Update更新 正常：200；异常：204、404、405 DELETE delete 正常：200、202、204；异常：404、405 2.1. PATCH 与 PUT 🔹 PATCH为更新某资源的部分数据（部分），PUT则是更新某资源的全部数据（整体）🔹 但只需修改部分数据时，也可用PUT发送需修改的数据，来替换PATCH。 2.2. POST的成功响应 🔹 以HTTP标准而言，POST应返回的成功状态码为201。🔹 也可直接响应新建资源的所有数据。 2.3. DELETE的响应内容 🔹 状态码200 ：删除成功，返回删除的具体信息（含body：code+message+data）204 ：删除成功，无返回内容（无body）202 ：接受删除请求，未执行 3. 风格设计 3.1. 接口 🔹 不使用动词,使用名词,以请求方法来作为动词🔹 为了统一,名词尽量为复数🔹 避免多级URL。&emsp;除了第一级，其他级别都用查询字符串表达。&emsp;eg: GET /authors/12?categories=2&emsp;&emsp;GET /articles?published=true 3.2. 响应信息 1234567891011121314151617&#123; \"code\": xxx, \"message\": \"\", \"data\":&#123;&#125;&#125;// 分页响应结果的参数（可选）&#123; // 可放在data中或外部 \"page|currentPage\": xxx, // 当前页码 \"numPerPage\": xxx, // 每页个数 \"pages|totalPageNum\": xxx, // 总页数 \"total\": xxx, // 总个数 \"hasPrev\": boolean, // 是否有上一页 \"hasNext\": boolean, // 是否有下一页 \"items\" : &#123;&#125; // 列表数据内容&#125; 📘参考、摘取文章：RESTful API 最佳实践–阮一峰HTTP后台端：RESTful API接口设计","categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"name":"RESTful","slug":"个人笔记/RESTful","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/RESTful/"}],"tags":[{"name":"RESTful","slug":"RESTful","permalink":"https://jianxilin.github.io/tags/RESTful/"}]},{"title":"SpringCache的简单使用","slug":"SpringCache的简单使用","date":"2020-06-07T08:56:29.000Z","updated":"2020-06-07T09:05:20.831Z","comments":true,"path":"2020/06/07/SpringCache的简单使用/","link":"","permalink":"https://jianxilin.github.io/2020/06/07/SpringCache%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","excerpt":"1. 简述 &emsp;&emsp;为各个缓存技术提供一个接口规范。&emsp;&emsp;其中CacheManager是Spring提供的各种缓存技术抽象接口，Cache接口则提供缓存的相关操作。 🔹SpringBoot中的整合：&emsp;&emsp;在Springboot中则默认配置了多个CacheManager的实现，默认使用ConcurrenMapCacheManager。&emsp;&emsp;若使用多个CacheManager，则可通过注入实现CachingConfigurerSupport接口的配置类来设置。","text":"1. 简述 &emsp;&emsp;为各个缓存技术提供一个接口规范。&emsp;&emsp;其中CacheManager是Spring提供的各种缓存技术抽象接口，Cache接口则提供缓存的相关操作。 🔹SpringBoot中的整合：&emsp;&emsp;在Springboot中则默认配置了多个CacheManager的实现，默认使用ConcurrenMapCacheManager。&emsp;&emsp;若使用多个CacheManager，则可通过注入实现CachingConfigurerSupport接口的配置类来设置。 2. 结合Redis 2.1. 项目的创建 2.1. 使用redis 2.1.1. 在配置文件中配置基本信息 12345678//redis的相关配置spring.redis.host=106.15.72.132spring.redis.port=6379spring.redis.database=0spring.redis.password=//设置cahce名称spring.cache.cache-names=c1 2.1.2. 使用缓存 在将运用缓存的方法或类上添加相应的注解 @EnableCaching 在启动类注解@EnableCaching开启缓存 @Cacheable 标记哪个方法将使用缓存。默认方法所有方法为key,返回值为value。 主要参数如下： 🔹 cacheName指定缓存名称 🔹 key指定哪些内容作为缓存的key（默认为方法的所有参数） 取值 含义 案例 参数名 表示某个参数 method 该方法 #method、#method.name methodName 方法名称 #methodName args 方法参数 #args、#args[0] target 当前被调用的class #target caches 被调用的方法使用的缓存 #caches result 方法返回值（需先执行方法） #result condition 缓存添加，true时才进行缓存,使用SpEL #userName.length()&gt;2 12// 案例：指定参数名为id的值作为key@Cacheable(cacheNames = \"c1\",key = \"#id\") 🔹 keyGernerator自定义key先定义类，实现KeyGernerator接口，注入ioc容器。再通过该注解来指定。 12345678910111213141516// 自定义定义key@Componentpublic class MyKeyGernerator implements KeyGenerator &#123; /** * 设置 方法名-参数名 为key * @param o 当前被调用的对象 * @param method 方法 * @param objects 方法参数 * @return 方法名+参数名 */ @Override public Object generate(Object o, Method method, Object... objects) &#123; return method.getName()+\"-\"+ Arrays.toString(objects); &#125;&#125; 12// 指定自定义的key@Cacheable(cacheNames = \"c1\",keyGenerator = \"myKeyGernerator\") @CacheEvict 用于删除缓存。 特有的参数： 参数 含义 allEntries 是否删除所有缓存 beforeInvocation 是否先调用，即是否先删除缓存 12345//案例@CacheEvict(cacheNames = \"c1\",allEntries = false)public void deleteUserById(Integer id)&#123; System.out.println(\"&gt;&gt;&gt;deleteUserById()\");&#125; @CachePut 用于更新缓存，更新key值相同的缓存 12345@CachePut(cacheNames = \"c1\",key = \"#user.id\")public User updateUser(User user)&#123; System.out.println(\"&gt;&gt;&gt;updateUser()\"); return user;&#125; @CacheConfig 用于类上的注解，添加Cache的相关配置 特有的参数： 参数 含义 cacheNames 指定该类上的缓存使用的缓存名称 1@CacheConfig(cacheNames = \"c1\") @Caching 可用于使用多个注解,与其它Cache注解结合使用。 12345678@Caching(put = &#123; @CachePut(value = \"user\", key = \"#user.id\"), @CachePut(value = \"user\", key = \"#user.username\"), @CachePut(value = \"user\", key = \"#user.email\")&#125;)public User save(User user) &#123; .....&#125;","categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"个人笔记/Java","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/"},{"name":"SpringCache","slug":"个人笔记/Java/SpringCache","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/SpringCache/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jianxilin.github.io/tags/Java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://jianxilin.github.io/tags/SpringBoot/"},{"name":"SpringCache","slug":"SpringCache","permalink":"https://jianxilin.github.io/tags/SpringCache/"},{"name":"Redis","slug":"Redis","permalink":"https://jianxilin.github.io/tags/Redis/"}]},{"title":"SpringBoot整合SpringSecurity","slug":"SpringBoot整合SpringSecurity","date":"2020-06-07T08:33:33.000Z","updated":"2020-06-07T08:38:13.591Z","comments":true,"path":"2020/06/07/SpringBoot整合SpringSecurity/","link":"","permalink":"https://jianxilin.github.io/2020/06/07/SpringBoot%E6%95%B4%E5%90%88SpringSecurity/","excerpt":"1. jar包导入 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;","text":"1. jar包导入 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 2. 默认参数 导入SpringSecurity的jar包后，则生效。SpringSecurity默认拦截了所有请求，提供了表单登录，默认提供了一个User对象记录了默认的用户名、密码、角色等。 从SecuriryProperies类中可得出，用户名默认为user等信息。 123456789101112131415//SecuriryProperies类中的内部类public static class User &#123; /** * Default user name. */ private String name = \"user\"; /** * Password for the default user name. */ private String password = UUID.randomUUID().toString(); /** * Granted roles for the default user name. */ private List&lt;String&gt; roles = new ArrayList&lt;&gt;(); ... 可修改的自动配置参数： 12345678910111213# ----------------------------------------# SECURITY PROPERTIES# ----------------------------------------# SECURITY (SecurityProperties)spring.security.filter.order=0 # Security filter chain order.spring.security.filter.dispatcher-types=ASYNC,ERROR,REQUEST # Security filter chain dispatcher types.spring.security.user.name=user # Default user name.spring.security.user.password= # Password for the default user name.spring.security.user.roles= # Granted roles for the default user name.# SECURITY OAUTH2 CLIENT (OAuth2ClientProperties)spring.security.oauth2.client.provider.*= # OAuth provider details.spring.security.oauth2.client.registration.*= # OAuth client registrations. 3. 配置认证信息 SpringSecurity中认证信息的配置通过WebSecurityConfigurerAdapter接口内的configure(AuthenticationManagerBuilder auth)方法来配置。 3.1. 使用固定的认证信息 1234567@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.inMemoryAuthentication() .withUser(\"xi\").password(\"xi\").roles(\"admin\") .and() .withUser(\"ming\").password(\"ming\").roles(\"user\");&#125; 3.2. 使用数据库中的信息 在配置类中认证信息方法上，添加UserService类实例，该类需实现UserDetailsService接口,重写以下该方法：UserDetails loadUserByUsername(String var1) 该方法将返回的内容是与数据库相互映射的user实体类，其需实现UserDetails接口 🔹 配置类 1234567@AutowiredUserService userService;@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(userService);&#125; 🔹 service 12345678910111213141516@Servicepublic class UserService implements UserDetailsService &#123; @Autowired UserMapper userMapper; @Override public User loadUserByUsername(String username) &#123; User user = userMapper.loadUserByUsername(username); if (user == null) &#123; throw new UsernameNotFoundException(\"用户不存在\"); &#125; user.setRoles(userMapper.getRolesByUserId(user.getId())); return user; &#125;&#125; 🔹 user实体类 1234567891011public class User implements UserDetails &#123; private Integer id; private String username; private String password; private boolean enabled; private boolean locked; //是否被锁定 private List&lt;Role&gt; roles; ....&#125; 3.3. 密码加密 🔹 设置密码加密方式 可在配置类中注入PasswordEncoder类。注入其子类后，数据库则需存储其相应的加密后的密码（可使用该加密类中加密方法来手动获取加密后的密码） 直接使用Encoder,数据库则无需存储盐值。 1234@BeanPasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder();&#125; 💬 BCrypt为单向Hash加密,破解成本很高， BCrypt = BCrypt版本号 + salt盐 + Hash结果值其中Hash结果值 = Hash(明文密码,salt) 🔹 取消密码加密（已过时）在配置类中注入NoOpPasswordEncoder.getInstance() 1234@BeanPasswordEncoder passwordEncoder()&#123; return NoOpPasswordEncoder.getInstance();&#125; 3.4.设置角色继承关系 1234567@BeanRoleHierarchy roleHierarchy() &#123; RoleHierarchyImpl roleHierarchy = new RoleHierarchyImpl(); String hierarchy = \"ROLE_dba &gt; ROLE_admin \\n ROLE_admin &gt; ROLE_user\"; roleHierarchy.setHierarchy(hierarchy); return roleHierarchy;&#125; 4. HttpSecurity httpSecurity相关配置通过WebSecurityConfigurerAdapter的configure(HttpSecurity http)方法来配置。 4.1 控制请求路径权限（赋予角色） 4.1.1. 使用固定的资源路径权限信息 12345678910@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .antMatchers(\"/admin/**\").hasRole(\"admin\")// .antMatchers(\"user/**\").hasAnyRole(\"admin\",\"user\") .antMatchers(\"user/**\").access(\"hasAnyRole('admin','user')\") .anyRequest().authenticated() .and();&#125; 4.1.2. 动态更改 需要向容器注入两个类： 实现FilterInvocationSecurityMetadataSource接口的类 实现AccessDecisionManager接口的类 之后再将这两个类添加到HttpSecurity中。 FilterInvocationSecurityMetadataSource主要返回请求所需认证信息（角色）。AccessDecisionManager主要用来决定请求是否通过，通过返回，不通过则抛AccessDeniedException异常。 🔹 注入FilterInvocationSecurityMetadataSource 1234567891011121314151617181920212223242526272829303132333435363738@Componentpublic class MyFilter implements FilterInvocationSecurityMetadataSource &#123; //用于匹配url AntPathMatcher pathMatcher = new AntPathMatcher(); @Autowired MenuService menuService; /** * 根据请求地址设置所需要的角色 * 请求地址与数据库中无匹配项，则添加为需要登录 * @param o req + resp + chain * @return * @throws IllegalArgumentException */ @Override public Collection&lt;ConfigAttribute&gt; getAttributes(Object o) throws IllegalArgumentException &#123; //获取请求地址 String requestUrl = ((FilterInvocation) o).getRequestUrl(); //获取数据库中所有资源请求地址(含角色) List&lt;Menu&gt; allMenus = menuService.getAllMenus(); //查找当前请求路径与数据库中哪个资源请求匹配 // 匹配则返回其所需的认证信息（角色） for (Menu menu : allMenus) &#123; if (pathMatcher.match(menu.getPattern(), requestUrl)) &#123; List&lt;Role&gt; roles = menu.getRoles(); String[] rolesStr = new String[roles.size()]; for (int i = 0; i &lt; roles.size(); i++) &#123; rolesStr[i] = roles.get(i).getName(); &#125; return SecurityConfig.createList(rolesStr); &#125; &#125; // 无匹配项，默认返回 ROLE_login return SecurityConfig.createList(\"ROLE_login\"); &#125; ......&#125; 🔹 注入AccessDecisionManager 123456789101112131415161718192021222324252627282930313233343536373839404142@Componentpublic class MyAccessDecisionManager implements AccessDecisionManager &#123; /** * 根据当前角色信息，判断是否符合当前请求所需角色的要求 * @param authentication 当前登录用户的信息 * @param o 当前请求对象 * @param collection 当前请求对象所需的角色 对应着FilterInvocationSecurityMetadataSource * @throws AccessDeniedException * @throws InsufficientAuthenticationException */ @Override public void decide(Authentication authentication, Object o, Collection&lt;ConfigAttribute&gt; collection) throws AccessDeniedException, InsufficientAuthenticationException &#123; // 遍历所需角色信息 // 若当前角色在所需角色内，则返回，否则则抛异常 for (ConfigAttribute attribute : collection) &#123; if (\"ROLE_login\".equals(attribute.getAttribute())) &#123; if (authentication instanceof AnonymousAuthenticationToken) &#123; throw new AccessDeniedException(\"非法请求!\"); &#125; else &#123; return; &#125; &#125; Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities(); for (GrantedAuthority authority : authorities) &#123; if (authority.getAuthority().equals(attribute.getAttribute())) &#123; return; &#125; &#125; &#125; throw new AccessDeniedException(\"非法请求!\"); &#125; @Override public boolean supports(ConfigAttribute configAttribute) &#123; return true; &#125; @Override public boolean supports(Class&lt;?&gt; aClass) &#123; return true; &#125;&#125; 🔹 将自定义的两个类添加到HttpSecurity中 设置请求资源路径认证信息 判断请求内容是否符合认证信息 123456789101112131415161718@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .withObjectPostProcessor(new ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123; @Override public &lt;O extends FilterSecurityInterceptor&gt; O postProcess(O o) &#123; o.setAccessDecisionManager(myAccessDecisionManager); o.setSecurityMetadataSource(myFilter); return o; &#125; &#125;) .and() .formLogin() .permitAll() .and() .csrf().disable();&#125; 4.2. 配置登录表单 12345678910111213@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .formLogin() .loginProcessingUrl(\"/doLogin\") // .loginPage(\"/login\") //自定义登录页面 // .usernameParameter(\"uname\") //自定义参数名称 // .passwordParameter(\"password\") // // .successForwardUrl(\"/\") //登录成功后跳转到url .permitAll() ......&#125; 4.3. 登录成功\\失败后的操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() //登录成功后的操作 .successHandler((req, resp, authentication) -&gt; &#123; //authentication :登录成功的信息 PrintWriter writer = resp.getWriter(); resp.setContentType(\"application/json;charset=utf-8\"); HashMap&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"status\",200); map.put(\"message\",authentication.getPrincipal()); //向相应请求中写入信息 writer.write(new ObjectMapper().writeValueAsString(map)); writer.flush(); writer.close(); &#125;) // 登录失败后的操作 .failureHandler((req, resp, e) -&gt; &#123; PrintWriter writer = resp.getWriter(); resp.setContentType(\"application/json;charset=utf-8\"); HashMap&lt;String,Object&gt; map = new HashMap&lt;&gt;(10); map.put(\"status\",401); //判断失败的异常类型 if (e instanceof LockedException)&#123; map.put(\"message\",\"账号被锁定，登陆失败\"); &#125;else if (e instanceof BadCredentialsException)&#123; map.put(\"message\",\"账号或密码错误，登陆失败\"); &#125;else if (e instanceof DisabledException)&#123; map.put(\"message\",\"账号被禁用，登陆失败\"); &#125;else if (e instanceof AccountExpiredException)&#123; map.put(\"message\",\"账号过期，登陆失败\"); &#125;else if (e instanceof CredentialsExpiredException)&#123; map.put(\"message\",\"密码过期，登陆失败\"); &#125;else&#123; map.put(\"message\",\"登录失败\"); &#125; //向相应请求中写入信息 writer.write(new ObjectMapper().writeValueAsString(map)); writer.flush(); writer.close(); &#125;) ......&#125; 4.4. 退出登录 123456789101112131415161718192021@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() ... .logout() .logoutUrl(\"/logout\") //退出登录的请求url //退出成功后的操作 .logoutSuccessHandler((req, resp, authentication) -&gt; &#123; PrintWriter writer = resp.getWriter(); HashMap&lt;String,Object&gt; map = new HashMap&lt;&gt;(); resp.setContentType(\"application/json;charset=utf-8\"); map.put(\"status\",200); map.put(\"message\",\"注销成功\"); writer.write(new ObjectMapper().writeValueAsString(map)); writer.flush(); writer.close(); &#125;) ......&#125; 4.5. 关闭csrf 测试时使用。关闭csrf攻击的预防操作。 12345678@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() ... csrf().disable(); ......&#125; 5. 多个HttpSecurity 当多个HttpSecurity时，需在类上添加@order(value)注解来标明优先级。value值越低，优先级越高。 1234567891011121314151617181920212223242526272829303132333435@Configurationpublic class MuitlHttpSecurityConfig &#123; @Configuration @Order(1) static class AdminSecurity extends WebSecurityConfigurerAdapter&#123; @Override protected void configure(HttpSecurity http) throws Exception &#123;// http.authorizeRequests() 无效？// .antMatchers(\"/admin/**\").hasRole(\"admin\");// .antMatchers(\"user/**\").hasAnyRole(\"admin\",\"user\"); http.antMatcher(\"/admin/**\").authorizeRequests() .anyRequest().hasRole(\"admin\");// .and()// .antMatcher(\"user/**\").authorizeRequests()// .anyRequest().hasAnyRole(\"admin\",\"user\"); // 报错。why？？nested exception is java.lang.IllegalStateException: Can't configure anyRequest after itself &#125; &#125; @Configuration static class OtherSecurity extends WebSecurityConfigurerAdapter&#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .anyRequest().authenticated() .and() .formLogin().loginProcessingUrl(\"/doLogin\") .and() .csrf().disable(); &#125; &#125;&#125;","categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"个人笔记/Java","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/"},{"name":"SpringSecurity","slug":"个人笔记/Java/SpringSecurity","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/SpringSecurity/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jianxilin.github.io/tags/Java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://jianxilin.github.io/tags/SpringBoot/"},{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"https://jianxilin.github.io/tags/SpringSecurity/"}]},{"title":"validation的基本使用","slug":"validation的基本使用","date":"2020-05-27T13:26:39.000Z","updated":"2020-05-27T14:07:46.800Z","comments":true,"path":"2020/05/27/validation的基本使用/","link":"","permalink":"https://jianxilin.github.io/2020/05/27/validation%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"1、jar包引入 12345&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.0.9.Final&lt;/version&gt;&lt;/dependency&gt;","text":"1、jar包引入 12345&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.0.9.Final&lt;/version&gt;&lt;/dependency&gt; 2、校验注解 不仅仅只是可用在实体类中，也可用在（使用了@Validated ）controller、service的方法参数，service方法返回值。注解一般不会处理null情况。 👉原文链接 注解 使用 @NotNull 被注释的元素（任何元素）必须不为 null, 集合为空也是可以的。没啥实际意义 @NotEmpty 用来校验字符串、集合、map、数组不能为null或空 （字符串传入空格也不可以）（集合需至少包含一个元素） @NotBlank 只用来校验字符串不能为null，空格也是被允许的 。校验字符串推荐使用@NotEmpty @Size(max=, min=) 指定的字符串、集合、map、数组长度必须在指定的max和min内 允许元素为null，字符串允许为空格，==为null时，不生效。== @Length(min=,max=) 只用来校验字符串，长度必须在指定的max和min内 允许元素为null @Range(min=,max=) 用来校验数字或字符串的大小必须在指定的min和max内，字符串会转成数字进行比，如果不是数字校验不通过，允许元素为null @Min() 校验数字（包括integer short long int 等）的最小值，不支持小数即double和float，允许元素为null @Max() 校验数字（包括integer short long int 等）的最小值，不支持小数即double和float，允许元素为null @Pattern() 正则表达式匹配，可用来校验年月日格式，是否包含特殊字符（regexp = “^[a-zA-Z0-9\\u4e00-\\u9fa5 🔹 不常用 123456789@Null 被注释的元素必须为 null@AssertTrue 被注释的元素必须为 true@AssertFalse 被注释的元素必须为 false@DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值@DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值@Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内@Past 被注释的元素必须是一个过去的日期@Future 被注释的元素必须是一个将来的日期@Email 被注释的元素必须是电子邮箱地址 3、注解 3.1、@Validated 3.2、@RestController 3.3、@Valid 标记需验证的参数，可用于controller中方法的参数，也可在spring中， 可用于联级验证中的一对一、一对多。 A、一对一: 一个对象中包含另一个对象作为属性。 对这个对象属性添加该注解，这该对象中的验证也可使用。 B、一对多：一个对象中包含另一个对象容器作为属性。 注解可加在属性上，也可加载list泛型前。 3.4 @ExceptionHandler 在spring中，添加该注解的方法可对某异常进行捕获。 例如：MethodArgumentNotValidException e 4、在service中添加参数验收 4.1、实现方法 同controller。在类上添加@Validated，之后在需要进行参数验收 的参数前添加@Vaild。 4.2、注意事项 A、注解添加的位置。 @Vaild ：不能添加在接口实现类中，需放置在service的接口类中。 @Vaildated ：可添加在实现类或接口类中。 添加在接口类时，其对应的实现类也会进行参数验收。 B、需捕获的异常不同于controller。 并不是MethodArgumentNotValidException， 而是ConstraintViolationException(原生态的异常) 5、分组验收 无法使用于Service中 5.1、使用场景 对于不同功能，其对同一个实体的验证需求不同，则需要使用分组验收。 例如：添加新用户时，用户id需要为空值。而修改用户时，用户id则不能为空值。 5.2、实现 1️⃣ 设置分组 利用参数验证注解中的groups参数。 未设置分组的参数属于默认分组 2️⃣ 指定分组 由于@Valid无法实现该功能，故需使用@Validated来标记需参数验收的参数。 利用@Validated的value来指定分组。 6、自定义注解 6.1 实现 1️⃣ 实现注解（eg：MultipleOfThree） 2️⃣ 实现业务处理类（实现 ConstrainValidator接口） 7、校验List中的参数 7.1、获取validtor 1️⃣ 获取validtor 2️⃣ 从SpringBoot中获取(创建工具类获取，不直接注入到使用类中，因为Validtor非单例) 7.2、创建自定义注解 7.3、创建注解处理类 1️⃣ 注解处理类 2️⃣ 自定义异常类(由于处理类默认返回boolean,需改成抛出异常) 3️⃣ 捕获该异常类 4️⃣ 使用注解 8、参数间的逻辑校验 8.1、实现思路（分组动态化） 🔹 利用hibernate.validator 中提供的SequenceProvider——可进行分组的添加 &emsp;&emsp;通过SequenceProvider 来根据被校验的对象的属性变化，对添加分组。 8.2、实现方法 1️⃣ 创建SequenceProvider，在添加默认分组后，进行逻辑判断，以添加不同分组。 2️⃣ 使用SequenceProvider，在实体类中使用@GroupSequenceProvider","categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"个人笔记/Java","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/"},{"name":"validation","slug":"个人笔记/Java/validation","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/validation/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jianxilin.github.io/tags/Java/"},{"name":"vaildation","slug":"vaildation","permalink":"https://jianxilin.github.io/tags/vaildation/"},{"name":"数据校验","slug":"数据校验","permalink":"https://jianxilin.github.io/tags/%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/"}]},{"title":"axios的基本使用","slug":"axios的基本使用","date":"2020-05-27T12:58:49.000Z","updated":"2020-05-27T14:07:46.027Z","comments":true,"path":"2020/05/27/axios的基本使用/","link":"","permalink":"https://jianxilin.github.io/2020/05/27/axios%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"1. 简介 基于promise的对ajax的一个封装ajax适合于mvcpromise则适用于mvvm","text":"1. 简介 基于promise的对ajax的一个封装ajax适合于mvcpromise则适用于mvvm 2.使用 2.1 基本写法 123456789101112131415&lt;script src=\"https:unpkg.com.axios/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;script&gt; axios(&#123; url:\"url\", method:'get'|'post', //get为默认方式 param:&#123;--&#125; // param:&#123;name:小明&#125; //用过于get方法传参 同添加到url中 //post使用该参数，同样也是将参数添加到url中 data:&#123;--&#125; //用于post方法传参数 &#125;).then(res=&gt;&#123; console.log(res) &#125;).catch(err=&gt;&#123; console.log(err) &#125;)&lt;/script&gt; post传参注意点:带参请求默认为使用 application/json。1.param 可实现传参，但参数添加到url中2.使用axios.post(‘url’,’data’)3.使用data参数，后端对数据进行处理。如Springboot中使用@requestBody,将json转为java对象。 2.2 简写 2.2.1 get 1234567891011&lt;script src=\"https:unpkg.com.axios/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;script&gt; axios.get(&#123; \"url\", &#123;params:&#123;--&#125;&#125; // &#123;params:&#123;name:小明&#125;&#125; &#125;).then(res=&gt;&#123; console.log(res) &#125;).catch(err=&gt;&#123; console.log(err) &#125;)&lt;/script&gt; 2.2.2 post 123456789101112&lt;script src=\"https:unpkg.com.axios/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;script&gt; axios.post(&#123; \"url\", \"data\", // \"name=小明&amp;age=20\" &#123;data&#125; // &#123;data:&#123;name:'小明'&#125;&#125; &#125;).then(res=&gt;&#123; console.log(res) &#125;).catch(err=&gt;&#123; console.log(err) &#125;)&lt;/script&gt; 3.发送多个请求 3.1 使用res数组获取多个请求结果 1234567891011&lt;script src=\"https:unpkg.com.axios/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;script&gt; axios.all(&#123; axios.get(--), axios.get(--) &#125;).then(res=&gt;&#123; console.log(res[0]+res[1]) &#125;).catch(err=&gt;&#123; console.log(err) &#125;)&lt;/script&gt; 3.2 使用axios.spread()获取多个请求结果 12345678910111213&lt;script src=\"https:unpkg.com.axios/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;script&gt; axios.all(&#123; axios.get(--), axios.get(--) &#125;).then( axios.spread((res1,res2)=&gt;&#123; console.log(res1+res2) &#125;) &#125;).catch(err=&gt;&#123; console.log(err) &#125;)&lt;/script&gt; 4. 全局配置 可将公共数据提取出来，get、post请求内容中则无需再写这些公共内容。比如提取url的公共部分、提取超时参数。 1234567891011&lt;script src=\"https:unpkg.com.axios/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;script&gt; axios.defaults.baseurl=\"http://-:8080/person\", axios.defaults.timeout=3000, axios.get('getall').then(res=&gt;&#123; // == http://-:8080/person/getall console.log(res) &#125;) axios.post('update').then(res=&gt;&#123; // == http://-:8080/person/update console.log(res) &#125;)&lt;/script&gt; 5. axios实例 12345678910111213&lt;script src=\"https:unpkg.com.axios/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;script&gt; // 定义 let newVar = axios.create(&#123; baseURL:'url', timeout:5000 &#125;); // 使用 newVar(&#123; url:'getAll' &#125;)&lt;/script&gt; 6. 拦截器 12345678&lt;script src=\"https:unpkg.com.axios/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;script&gt; axios.interceptors.request.use(config=&gt;&#123; // 进入前 &#125;,err=&gt;&#123; // 发生错误 &#125;);&lt;/script&gt; 7. 在vue中进行模块封装 基于 import-export 来进行封装，类似函数封装 vue中安装axios: npm install axios –save 7.1 无返回值 🔹 封装内容 (位置 : /network/request/request.js): 12345678910import axios form 'axios'export function request(url,success,fail)&#123; axios(&#123; url:url &#125;).then(res=&gt;&#123; success(res) &#125;).catch(err=&gt;&#123; fail(err) &#125;)&#125; 🔹 调用: 12import &#123;request&#125; form './network/request/request.js'request(url,res=&gt;&#123;&#125;,err=&gt;&#123;&#125;) 7.2 返回Promise对象 Promise中需声明、创建实例.Promise为ES6中的语法点，其内容代指即将发生的事件 🔹 封装内容： 12345678910111213141516import axios form 'axios'export function request(config)&#123; return new Promise((resolve,reject)=&gt;&#123; //声明实例 let newVar = axios.create(&#123; baseURL:\"url\", timeout:5000 &#125;); //创建实例 newVar(config).then(res=&gt;&#123; resolve(res) //res将作为参数传给回调函数 &#125;).catch(err=&gt;&#123; reject(err) &#125;) &#125;)&#125; 🔹 调用 12import &#123;request&#125; form './network/request/request.js'request(&#123;url:'url'&#125;).then(res=&gt;&#123;&#125;).catch(err=&gt;&#123;&#125;) 7.3 返回实例 方法内声明实例。本质同返回Promise对象 🔹 封装内容： 12345678910import axios form 'axios'export function request(config)&#123; //声明实例 let newVar = axios.create(&#123; baseURL:\"url\", timeout:5000 &#125;); //创建实例并返回 return newVar(config);&#125; 🔹 调用 12import &#123;request&#125; form './network/request/request.js'request(&#123;url:'url'&#125;).then(res=&gt;&#123;&#125;).catch(err=&gt;&#123;&#125;)","categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"name":"前端","slug":"个人笔记/前端","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF/"},{"name":"axios","slug":"个人笔记/前端/axios","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF/axios/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://jianxilin.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"axios","slug":"axios","permalink":"https://jianxilin.github.io/tags/axios/"}]},{"title":"[总结]Java容器","slug":"总结-Java容器","date":"2020-05-21T07:42:36.000Z","updated":"2020-05-21T07:45:29.851Z","comments":true,"path":"2020/05/21/总结-Java容器/","link":"","permalink":"https://jianxilin.github.io/2020/05/21/%E6%80%BB%E7%BB%93-Java%E5%AE%B9%E5%99%A8/","excerpt":"1. List、Map、Set 🔹 List: 用于排序。元素有序、可重复。&emsp;&emsp;&emsp;&emsp;实现：Object数组 | 双向链表🔹 Map：用于搜索。存储键值对。key不可重复。&emsp;&emsp;&emsp;&emsp;实现：数组+链表（JDK1.8前），数组+链表+红黑树（JDK1.8~）🔹 Set：无重复（去重）。不可重复。&emsp;&emsp;&emsp;&emsp;实现：使用Map中的Key","text":"1. List、Map、Set 🔹 List: 用于排序。元素有序、可重复。&emsp;&emsp;&emsp;&emsp;实现：Object数组 | 双向链表🔹 Map：用于搜索。存储键值对。key不可重复。&emsp;&emsp;&emsp;&emsp;实现：数组+链表（JDK1.8前），数组+链表+红黑树（JDK1.8~）🔹 Set：无重复（去重）。不可重复。&emsp;&emsp;&emsp;&emsp;实现：使用Map中的Key RandomAccess：标记型接口。表示可随机访问元素（可快速访问）。 2. List 2.1 ArrayList、LinkedList 区别 2.1.1 底层实现 🔹 ArrayList：数组🔹 LinkedList：双向链表（1.7~），1.7之前是循环链表。 循环链表相比双向链表的缺点：&emsp;1️⃣ 初始化时，需先创建一个空节点作为头节点，以避免需要多次校验头节点是否为null。&emsp;2️⃣ 头尾部节点不够清晰，且在头尾部分进行增删时，需处理头尾部两个节点的指针。 2.1.2 增删元素 🔹 ArrayList：默认时，复杂度O(1)。指定位置时，复杂度O(n-i)。 增删某元素将对后续元素位置产生影响。不指定位置则默认增加到尾部。🔹 LinkedList: 复杂度O(1)。 2.1.3 查找元素 🔹 ArrayList：可快速查询🔹 LinkedList：需遍历查询 2.1.4 线程安全性 🔹 两者都是非线程安全的 2.1.5 空间占用 🔹 ArrayList：需要预留容量空间🔹 LinkedList：每个节点需存储前继和后续节点的指针 2.1.6 扩容 🔹 ArrayList：+50%,初始值10🔹 LinkedList：且无需扩容,无初始值 2.2 ArrayList、Vector 区别 2.2.1 线程安全性 🔹 ArrayList：非线程安全🔹 Vector：线程安全 2.2.2 效率 🔹 ArrayList：效率更高🔹 Vector：效率低 Vector每个方法都添加了同步，即Synchronized。导致效率低。 2.2.3 扩容 🔹 ArrayList：增加 50%，初始容量10🔹 Vector：增加 100%，初始容量10 12//ArrayList的grow中的增加的值int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); 3. Map and Set 3.1 HashMap 与 HashTable(不使用) 3.1.1 底层实现 🔹 HashMap: 数组+红黑树+链表(1.8~),1.8前是数组+链表&emsp; jdk1.8，为了解决哈希冲突所带来的问题，当链表长度大于阈值(默认为8)，且当前长度不小于64，则将链表转为红黑树。若长度小于64，则是进行扩容。🔹 HashTable: 数组+链表 3.1.2 线程安全性 🔹 HashMap：线程不安全。若需线程安全可使用ConcurrentHashMap🔹 HashTable：线程安全。几乎大部分方法都加了同步 3.1.3 效率 🔹 HashMap：效率高🔹 HashTable：效率低 3.1.4 扩容 🔹 HashMap:增加一倍。初始值为16。扩容因子默认为0.75&emsp;若指定大小时，长度将为比该值稍大或等于的2的幂次方。这是由于hash%length==hash&amp;(2^n-1)，且&amp;的效率高于%。&emsp;eg: 指定值为50, 50 &lt; 2^6. 故容量为2^6=16 🔹 HashTable:增加一倍,再+1.初始值为11 3.1.5 null值的处理 🔹 HashMap:key和value都支持null值，key仍不可重复🔹 HashTable:抛NullPointerException 3.2 HashMap 与 HashSet 3.2.1 底层实现 HashSet底层与HashMap一致，其内部调用了HashMap的方法。 1234567891011//HashSet 中的代码：其中的方法实现是通过HashMap代理来实现private transient HashMap&lt;E,Object&gt; map;private static final Object PRESENT = new Object();public int size() &#123; return map.size();&#125;public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; 3.2.2 对Hashcode的计算 🔹 HashMap：根据key和value进行运算🔹 HashSet：没有重写HashCode方法，value值以空对象代替。 123456789101112131415161718192021//该节点类为HashMap中内部类static class Node&lt;K, V&gt; implements Entry&lt;K, V&gt; &#123; //key和value的地址进行异或运算（不同则1，相同则0） public final int hashCode() &#123; return Objects.hashCode(this.key) ^ Objects.hashCode(this.value); &#125; public final boolean equals(Object var1) &#123; if (var1 == this) &#123; return true; &#125; else &#123; if (var1 instanceof Entry) &#123; Entry var2 = (Entry)var1; if (Objects.equals(this.key, var2.getKey()) &amp;&amp; Objects.equals(this.value, var2.getValue())) &#123; return true; &#125; &#125; return false; &#125; &#125;&#125; 📁内容补充：hashcode() 与 equals() 🔹 Object中的hashcode()，是关于其该对象实例的内存地址。🔹 Map中，hashcode 相同，equals不一定相等，表示在同一个散列数据结构（链表）。equal相等，hashcode一定相等。🔹 由于hashcode存在冲突，故需要使用equals进行判断。 3.3 ConcurrentHashMap 与 HashTable 两者都是线程安全。HashTable几乎所有方法都添加了同步，效率低。JDK1.7的ConcurrentHashMap则是来取代HashTable。 3.3.1 底层实现 🔹 ConcurrentHashMap：同HashMap🔹 HashTable：数组+链表 3.3.2 线程安全的策略 🔹 ConcurrentHashMap：使用“分段式锁”。&emsp;每一段数据分别加锁。而且加的锁是ReentrantLock可重入锁。&emsp;👉图片来源 🔹 HashTable：大部分方法添加了同步。如put/get方法添加了Synchronzed。&emsp;效率很低，近似整个容器对象添加了锁。&emsp;👉图片来源","categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"个人笔记/Java","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/"},{"name":"基础","slug":"个人笔记/Java/基础","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/%E5%9F%BA%E7%A1%80/"},{"name":"容器","slug":"个人笔记/Java/基础/容器","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/%E5%9F%BA%E7%A1%80/%E5%AE%B9%E5%99%A8/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jianxilin.github.io/tags/Java/"},{"name":"Java容器","slug":"Java容器","permalink":"https://jianxilin.github.io/tags/Java%E5%AE%B9%E5%99%A8/"}]},{"title":"[总结]Git的基本使用","slug":"总结-Git的基本使用","date":"2020-05-13T03:48:49.000Z","updated":"2020-06-01T13:25:00.301Z","comments":true,"path":"2020/05/13/总结-Git的基本使用/","link":"","permalink":"https://jianxilin.github.io/2020/05/13/%E6%80%BB%E7%BB%93-Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"Git作为一个版本控制的工具,在我们学习过程中是必不可少的。不仅是Git仓库GitHub、Gitee，还是在编辑器VSCode，Git在管理文件、控制文件版本、回退文件、多人协作、并发开发等有着重要的地位。以下将对Git的基本使用继续总结、记录。","text":"Git作为一个版本控制的工具,在我们学习过程中是必不可少的。不仅是Git仓库GitHub、Gitee，还是在编辑器VSCode，Git在管理文件、控制文件版本、回退文件、多人协作、并发开发等有着重要的地位。以下将对Git的基本使用继续总结、记录。 1. Git与SVN的简单区分 🔹 实现方式上&emsp;SVN : 集中版本控制。SVN所控制的所有版本内容存储在单一服务器上，本地用户在未联网的情况下，只能看到所同步的版本内容。&emsp;Git : 分布式版本控制。不同于SVN，本地的每个本地用户都能获取到所有版本内容，且Commit操作是在用户本地进，之后再push到远端仓库。&emsp;Git相比SVN，空间成本增加了，且安全性也有所下降，但也减少了数据损失而无法恢复的风险。 🔹 克隆多分支项目&emsp;SVN克隆所有分支的内容&emsp;Git克隆master分支,其它分支只获取相关元素，节省了时间。 2. Git的基本使用 2.1 配置信息 🔹 获取配置信息： 123456// 获取全部配置信息git config -l// 获取系统级别配置信息，对应 \\git主目录\\etc\\gitconfiggit config --system -l// 获取用户(全局)级别的配置信息，对应 \\user\\Administrator\\.gitconfiggit config --global -l 🔹 配置全局的用户信息 12git config --global user.name \"用户名\"git config --global user.email 邮箱 2.2 操作仓库内容 🔹 初始化本地仓库 1git init 🔹 添加到缓存并提交到本地仓库 12git add . git commit -m \"注释\\提交的说明信息\" 🔹 提交到远程仓库 1git push 地址 master 🔹 克隆远程仓库 \\ 获取远程代码 12git clone 地址 分支(eg:master)git pull 地址 分支(eg:master) 🔹 查看本地文件状态 1git status 3.HEAD HEAD 指当前分支的最近一次提交head 指commit对象 head 包含 HEAD 🔹 占位符 ~ 与 ^ ~ ： 表示祖先commit&emsp;&emsp;eg : HEAD~ = HEAD~1 = 前一代commit（父辈）&emsp;&emsp;&emsp;HEAD~~ = HEAD~2 = 前两代commit（爷爷辈）^ : 单个父辈时，与 ~ 基本一致。&emsp;&emsp;多个父辈时，^ = ^1 = 第一个父辈 🔹 案例 1234567891011121314151617181920G H I J \\ / \\ / D E F \\ | / \\ \\ | / | \\|/ | B C \\ / \\ / AA = = A^0B = A^ = A^1 = A~1C = A^2 = A^2D = A^^ = A^1^1 = A~2E = B^2 = A^^2F = B^3 = A^^3G = A^^^ = A^1^1^1 = A~3H = D^2 = B^^2 = A^^^2 = A~2^2I = F^ = B^3^ = A^^3^J = F^2 = B^3^2 = A^^3^2 👉此内容参考来源 4. 信息查看 🔹 获取本地文件状态 1git status 🔹 获取commit历史信息 12git loggit log --oneline 🔹 查看当前索引(暂存区) 1git ls-files -s 🔹 显示了 HEAD 快照实际的目录列表 1git cat-file -p HEAD 🔹 查看HEAD的当前指向 1cat .git/HEAD 🔹 查看HEAD各个祖先 1git rev-parse HEAD~ //前一个祖先(父辈) 5. 撤销操作 🔹 git checkout [不写|HEAD] &lt;file&gt; //旧版 🔹 git restore [不写|–staged] &lt;file&gt; //新版 🔹 git reset [–hard|soft|mixed(默认)|merge|keep] [commit|HEAD](1) –soft : 回退到暂存区状态(2) –mixed : 回退到本地状态（本地修改的内容存在）(3) –hard : 回退到某次提交，清除所有历史状态，包括本地文件内容。 🔹 git revert HEAD^ 重新提交，保留历史记录 git reset不保留历史记录 🔹 重写最后一次commit 1git commit --amend -m 6. 冲突解决 🔹 提交时，发生冲突 执行git pull，发生冲突后，git会将两个版本的内容合并在一起。解决：先git status，查找发生冲突的文件，自行修改冲突内容后再提交，pull 🔹 回退commit，发生冲突 执行revert HEAD^，发生冲突。解决：同样查看冲突、修改冲突后，执行git revert –continue。 7. Git的分支处理 🔹 常用命令 12345678910111213141516171819202122232425262728# 列出所有本地分支git branch# 列出所有远程分支git branch -r# 新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支git checkout -b [branch]# 将分支推到远端git push 地址 dev(分支名):dev(分支名)# 切换分支git checkout [branch]# 合并指定分支到当前分支$ git merge [branch]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 👉此内容来源 参考文章：狂神说 聊Git📘CSDN 奋飛 Git Pro深入浅出（二）📘","categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"name":"工具","slug":"个人笔记/工具","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7/"},{"name":"版本控制","slug":"个人笔记/工具/版本控制","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"Git","slug":"个人笔记/工具/版本控制/Git","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/"}],"tags":[{"name":"版本控制","slug":"版本控制","permalink":"https://jianxilin.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"Git","slug":"Git","permalink":"https://jianxilin.github.io/tags/Git/"}]},{"title":"[总结]CSS样式失效的原因","slug":"总结-CSS样式失效的原因","date":"2020-05-11T06:49:33.000Z","updated":"2020-05-11T08:50:02.318Z","comments":true,"path":"2020/05/11/总结-CSS样式失效的原因/","link":"","permalink":"https://jianxilin.github.io/2020/05/11/%E6%80%BB%E7%BB%93-CSS%E6%A0%B7%E5%BC%8F%E5%A4%B1%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0/","excerpt":"CSS样式生效，需要正确的语法，并且其样式内容不被覆盖。以下先总结三点原因（后续再补充）：🔹 错误使用单行注释🔹 CSS选择器优先级较低🔹 Chrome浏览器存在CSS文件缓存","text":"CSS样式生效，需要正确的语法，并且其样式内容不被覆盖。以下先总结三点原因（后续再补充）：🔹 错误使用单行注释🔹 CSS选择器优先级较低🔹 Chrome浏览器存在CSS文件缓存 1. 在外部CSS中不能使用单行注释 在CSS选择器上使用单行注释，将导致该注释下的这个CSS选择器里面的内容失效。如下代码所示,“.post-readmore__link{}”将失效,“.post-readmore__link:hover{}”有效，不会受到影响。 1234567//readmore button （第一个CSS选择器无效）.post-readmore__link&#123; background-color: #27ae60;&#125;.post-readmore__link:hover&#123; background-color: #1f7f47;&#125; 而单行注释添加在CSS样式内，该CSS仍有效 123.post-readmore__link&#123; background-color: #27ae60; //green （有效）&#125; 若需要使用注释，可使用多行注释。如下： 1234/* readmore button */.post-readmore__link&#123; background-color: #27ae60; //green （有效）&#125; 2. CSS选择器优先级低于原有的CSS选择器 2.1. 当多个CSS选择器选择目标相同时 🔹 级别相同，后加载的CSS选择器覆盖前CSS选择器中相同的样式。🔹 级别不同，高级别CSS选择器覆盖低级别CSS选择器中相同的样式。 2.2. 级别判断 🔹 内嵌式CSS级别高于外部CSS，可视为最高级别。 🔹 #ID &gt; .Class、属性选择器([type=”button”])和伪类(:hover) &gt; 标签类型和伪元素(::after)级别计算案例：图片内容来源：MDN Web Docs 🔹 使用!important覆盖任何样式声明 123.post-readmore__link&#123; background-color: #27ae60 !important;&#125; 对于都添加！important的样式，则再由其选择器优先级来判断。 3.chrome浏览器存在缓存 🔹 原因:&emsp;&emsp;chrome浏览器为了提高加载效率，缓存了JS、CSS文件，故修改后的文件无法立即生效。 🔹 解决方法：方式一：来回切换开启缓存来重置缓存内容（不一定有效）。&emsp;&emsp;F12打开开发者工具，进入Network，在Disable cache前打勾✔，刷新页面。再把Disable cache关闭，取消✔，再次刷新页面。 方式二：来回切换开启缓存来重置缓存内容&emsp;&emsp;F12打开开发者工具，然后在浏览器的刷新按钮右击，选择“清空缓存并硬性重新加载”","categories":[{"name":"踩坑记录","slug":"踩坑记录","permalink":"https://jianxilin.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"},{"name":"前端","slug":"踩坑记录/前端","permalink":"https://jianxilin.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"踩坑记录/前端/CSS","permalink":"https://jianxilin.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://jianxilin.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"CSS","permalink":"https://jianxilin.github.io/tags/CSS/"}]},{"title":"个人博客[2]——美化","slug":"个人博客-2-——美化","date":"2020-05-11T06:46:50.000Z","updated":"2020-05-11T06:56:49.141Z","comments":true,"path":"2020/05/11/个人博客-2-——美化/","link":"","permalink":"https://jianxilin.github.io/2020/05/11/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-2-%E2%80%94%E2%80%94%E7%BE%8E%E5%8C%96/","excerpt":"环境要求：node.js 和 npm基于 Hexo博客框架基于 Hexo主题stun 美化内容以下：🔹 主题设置🔹 博客主题样式自定义🔹 博客文章样式自定义","text":"环境要求：node.js 和 npm基于 Hexo博客框架基于 Hexo主题stun 美化内容以下：🔹 主题设置🔹 博客主题样式自定义🔹 博客文章样式自定义 效果图： 👉Hexo官方地址 👉Hexo-theme-stun官方地址 1. 修改主题 1.1. 下载主题(stun) git clone https://github.com/liuyib/hexo-theme-stun.git themes/stun 1.2. 配置主题 修改_config.yml 123#Extensions...theme: yilia 1.3. Hexo重设与发布 清除 hexo clean 创建 hexo g 启动 hexo s 推到远端 hexo d 2. 基本样式修改 主题的相关设置详见官方文档📗 可修改Hexo主路径下的_config.yml,将生效于所有主题。也可修改hexo/theme/stun下的_config.xml,将只生效于stun主题。 2.1. 修改博客图标等图片 🔹 方式一：覆盖原图像 在Hexo主路径下的\\themes\\stun\\source\\images\\icons中，使用相同大小的图片覆盖。之后查看stun下的_config.xml是否开启对应的功能。 🔹 方式二：自定义路径 在_config.xml相应的配置下，设置图片路径为自定义图片路径（Hexo下的路径、图床上的路径） 2.2. 修改网页样式 🔹 修改文章样式 将CSS样式添加到stun主题的路径下的\\source\\css_custom\\index.styl文件内即可。内容如下： 1234567891011121314151617// Custom styles by yourself.// You should always modify the style here, not in the source code.// Otherwise, when the theme is updated, the code you modified will be overwritten.body &#123; // modify your style here // eg: background-color: blue; h1 &#123; text-align: center; &#125; h1, h2&#123; color: #4CAF50; &#125; ...&#125; 🔹 修改博客样式 （1）在stun主题的路径下的\\source\\css创建文件夹，自定义名称，名称前需带”_”，例如：_myCss。在该创建的文件夹下放置个人的CSS文件。（2）配置CSS文件。在stun\\source\\css\\index.styl文件内添加以下内容：@import ‘个人的CSS文件全路径’如下： 12345678910111213141516// Variables Layer// --------------------------------------------------@import './_variables/index.styl';// Mixins Layer// --------------------------------------------------@import './_mixins/index.styl';// Common Layer// --------------------------------------------------@import './_common/index.styl';// Custom Layer// --------------------------------------------------@import './_custom/index.styl';// MyCSS// --------------------------------------------------@import './_myCss/myCss.css';","categories":[{"name":"个人博客","slug":"个人博客","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"个人博客","slug":"个人博客","permalink":"https://jianxilin.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}]},{"title":"个人博客[3]——写作","slug":"个人博客-3-——写作","date":"2020-05-11T06:44:24.000Z","updated":"2020-05-11T06:55:24.757Z","comments":true,"path":"2020/05/11/个人博客-3-——写作/","link":"","permalink":"https://jianxilin.github.io/2020/05/11/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-3-%E2%80%94%E2%80%94%E5%86%99%E4%BD%9C/","excerpt":"环境要求：node.js 和 npm基于 Hexo博客框架基于 Hexo主题stun 本文内容包含：🔹 创建、修改、删除文章🔹 创建分类、标签页面🔹 在stun主题内开启分页和标签页面","text":"环境要求：node.js 和 npm基于 Hexo博客框架基于 Hexo主题stun 本文内容包含：🔹 创建、修改、删除文章🔹 创建分类、标签页面🔹 在stun主题内开启分页和标签页面 1. 创建 具体操作见官方文档📗 1.1. 创建文章 12hexo n \"文章名称\"hexo c &amp; hexo g 1.2. 创建分类、标签页面（即创建页面） 🔹 创建分类页面 在Hexo主路径下，执行以下命令 1hexo new page categories 在文章编写时，在文章顶部的Front-matter添加分类信息： 1234categories： - 分类名称 - 下一级分类名称 - [同级分类名称...] 🔹 创建标签页面 与创建分页页面相同，将categories改为tags即可。不同的是，Front-matter中的tags没有分级。 例子： 12345678910---title: '个人博客[1]——搭建'date: 2020-05-10 17:39:21tags: 个人博客categories: - 个人博客photos: - url--- 🔹 在stun主题内开启分页和标签页面 在stun主路径下的_config.yml配置文件的menu节点下添加页面配置信息，如下 1234567menu: home: / || fas fa-home archives: /archives/ || fas fa-folder-open categories: /categories/ || fas fa-layer-group tags: /tags/ || fas fa-tags # You can add a secondary menu like follow. # xxx1: javascript:; || fa(s|r|l|d|b) fa-xxx 效果图： 2.修改 2.1. 修改文章名称 &emsp;&emsp;Hexo未提供修改文件名称的命令。 🔹 解决方法： &emsp;&emsp;最简单的方式就是重新创建该文章，将要修改文章迁移过去。单独修改文章名称和修改文章内的Title标签是无效的。&emsp;&emsp;也可使用hexo-console-renamer插件，后续使用后再来补充。 2.2 删除文章 &emsp;&emsp;同样的，Hexo未提供删除文章的命令。 🔹 解决方法： &emsp;&emsp;在Hexo主路径下的\\source_posts文件夹内，手动删除文章文件，之后再重新创建博客内容，即运行以下命令 1hexo c &amp; hexo g","categories":[{"name":"个人博客","slug":"个人博客","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"个人博客","slug":"个人博客","permalink":"https://jianxilin.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}]},{"title":"个人博客[1]——搭建","slug":"个人博客-1-——搭建","date":"2020-05-10T09:39:21.000Z","updated":"2020-05-11T04:32:41.744Z","comments":true,"path":"2020/05/10/个人博客-1-——搭建/","link":"","permalink":"https://jianxilin.github.io/2020/05/10/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-1-%E2%80%94%E2%80%94%E6%90%AD%E5%BB%BA/","excerpt":"环境要求：node.js 和 npm基于 Hexo博客框架 👉Hexo官方地址","text":"环境要求：node.js 和 npm基于 Hexo博客框架 👉Hexo官方地址 1. 配置环境 安装node.js和npm修改npm的镜像为阿里镜像，即按照cnpm 安装cnpm cmd命令： &emsp;&emsp;npm install -g cnpm –registry=https://registry.npm.taobao.org 安装测试： &emsp;&emsp;cnpm -v 2. 安装Hexo框架 2.1. 安装：cnpm install -g hero-cli 2.2. 验证安装：hexo -v 3. 初始化Hexo博客 3.1. 初始化hexo项目：hexo init 3.2. 启动项目：hexo s 4. 添加第一篇文章 👉Hexo官方:写作 创建新文章：hexo n 文件名 清理：hexo clean 生成文章：hexo g 重启：hexo s 5. 部署到GitHub上 5.1. 创建git仓库,名称为 “git账号名.github.io”5.2. 安装github部署插件。 在本地博客路径下，运行 cnpm install –save hexo-deployer-git 5.3. 添加仓库信息 修改_config.yml。 在#deployment节点下，内容如下： ==冒号后需 + 空格== 12345#deploymentdeploy: type: git repo: 仓库地址 branch: master5.4. 部署到远端 hexo d","categories":[{"name":"个人博客","slug":"个人博客","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"个人博客","slug":"个人博客","permalink":"https://jianxilin.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}]}],"categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"个人笔记/数据库","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"NoSQL","slug":"个人笔记/数据库/NoSQL","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/"},{"name":"Redis","slug":"个人笔记/数据库/NoSQL/Redis","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/Redis/"},{"name":"Docker","slug":"个人笔记/Docker","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Docker/"},{"name":"Java","slug":"个人笔记/Java","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/"},{"name":"Spring","slug":"个人笔记/Java/Spring","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/Spring/"},{"name":"SpEL","slug":"个人笔记/Java/Spring/SpEL","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/Spring/SpEL/"},{"name":"RESTful","slug":"个人笔记/RESTful","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/RESTful/"},{"name":"SpringCache","slug":"个人笔记/Java/SpringCache","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/SpringCache/"},{"name":"SpringSecurity","slug":"个人笔记/Java/SpringSecurity","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/SpringSecurity/"},{"name":"validation","slug":"个人笔记/Java/validation","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/validation/"},{"name":"前端","slug":"个人笔记/前端","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF/"},{"name":"axios","slug":"个人笔记/前端/axios","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF/axios/"},{"name":"基础","slug":"个人笔记/Java/基础","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/%E5%9F%BA%E7%A1%80/"},{"name":"容器","slug":"个人笔记/Java/基础/容器","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Java/%E5%9F%BA%E7%A1%80/%E5%AE%B9%E5%99%A8/"},{"name":"工具","slug":"个人笔记/工具","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7/"},{"name":"版本控制","slug":"个人笔记/工具/版本控制","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"Git","slug":"个人笔记/工具/版本控制/Git","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/"},{"name":"踩坑记录","slug":"踩坑记录","permalink":"https://jianxilin.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"},{"name":"前端","slug":"踩坑记录/前端","permalink":"https://jianxilin.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"踩坑记录/前端/CSS","permalink":"https://jianxilin.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/%E5%89%8D%E7%AB%AF/CSS/"},{"name":"个人博客","slug":"个人博客","permalink":"https://jianxilin.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://jianxilin.github.io/tags/Redis/"},{"name":"NoSQL","slug":"NoSQL","permalink":"https://jianxilin.github.io/tags/NoSQL/"},{"name":"Docker","slug":"Docker","permalink":"https://jianxilin.github.io/tags/Docker/"},{"name":"Java","slug":"Java","permalink":"https://jianxilin.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://jianxilin.github.io/tags/Spring/"},{"name":"SpEL","slug":"SpEL","permalink":"https://jianxilin.github.io/tags/SpEL/"},{"name":"RESTful","slug":"RESTful","permalink":"https://jianxilin.github.io/tags/RESTful/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://jianxilin.github.io/tags/SpringBoot/"},{"name":"SpringCache","slug":"SpringCache","permalink":"https://jianxilin.github.io/tags/SpringCache/"},{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"https://jianxilin.github.io/tags/SpringSecurity/"},{"name":"vaildation","slug":"vaildation","permalink":"https://jianxilin.github.io/tags/vaildation/"},{"name":"数据校验","slug":"数据校验","permalink":"https://jianxilin.github.io/tags/%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/"},{"name":"前端","slug":"前端","permalink":"https://jianxilin.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"axios","slug":"axios","permalink":"https://jianxilin.github.io/tags/axios/"},{"name":"Java容器","slug":"Java容器","permalink":"https://jianxilin.github.io/tags/Java%E5%AE%B9%E5%99%A8/"},{"name":"版本控制","slug":"版本控制","permalink":"https://jianxilin.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"Git","slug":"Git","permalink":"https://jianxilin.github.io/tags/Git/"},{"name":"CSS","slug":"CSS","permalink":"https://jianxilin.github.io/tags/CSS/"},{"name":"个人博客","slug":"个人博客","permalink":"https://jianxilin.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}]}