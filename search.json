[{"title":"axios的基本使用","url":"/2020/05/27/axios的基本使用/","content":"\n## 1. 简介\n\n基于promise的对ajax的一个封装\najax适合于mvc\npromise则适用于mvvm\n<!--more-->\n## 2.使用\n\n### 2.1 基本写法\n\n```html\n<script src=\"https:unpkg.com.axios/dist/axios.min.js\"></script>\n<script>\n    axios({\n        url:\"url\",\n        method:'get'|'post', //get为默认方式\n        param:{--}  // param:{name:小明}\n                    //用过于get方法传参 同添加到url中\n                    //post使用该参数，同样也是将参数添加到url中\n        data:{--}  //用于post方法传参数\n    }).then(res=>{\n        console.log(res)\n    }).catch(err=>{\n        console.log(err)\n    })\n</script>\n```\n\n> post传参注意点:\n> 带参请求默认为使用 application/json。\n> 1.param 可实现传参，但参数添加到url中\n> 2.使用axios.post('url','data')\n> 3.使用data参数，后端对数据进行处理。如Springboot中使用@requestBody,将json转为java对象。\n\n### 2.2 简写\n\n#### 2.2.1 get\n\n```html\n<script src=\"https:unpkg.com.axios/dist/axios.min.js\"></script>\n<script>\n    axios.get({\n        \"url\",\n        {params:{--}} // {params:{name:小明}}\n    }).then(res=>{\n        console.log(res)\n    }).catch(err=>{\n        console.log(err)\n    })\n</script>\n```\n\n#### 2.2.2 post\n\n```html\n<script src=\"https:unpkg.com.axios/dist/axios.min.js\"></script>\n<script>\n    axios.post({\n        \"url\",\n        \"data\", // \"name=小明&age=20\"\n        {data}  // {data:{name:'小明'}}\n    }).then(res=>{\n        console.log(res)\n    }).catch(err=>{\n        console.log(err)\n    })\n</script>\n```\n\n## 3.发送多个请求\n\n### 3.1 使用res数组获取多个请求结果\n\n```html\n<script src=\"https:unpkg.com.axios/dist/axios.min.js\"></script>\n<script>\n    axios.all({\n        axios.get(--),\n        axios.get(--)\n    }).then(res=>{\n        console.log(res[0]+res[1])\n    }).catch(err=>{\n        console.log(err)\n    })\n</script>\n```\n\n### 3.2 使用axios.spread()获取多个请求结果\n\n```html\n<script src=\"https:unpkg.com.axios/dist/axios.min.js\"></script>\n<script>\n    axios.all({\n        axios.get(--),\n        axios.get(--)\n    }).then(\n        axios.spread((res1,res2)=>{\n            console.log(res1+res2)\n        })\n    }).catch(err=>{\n        console.log(err)\n    })\n</script>\n```\n\n## 4. 全局配置\n\n可将公共数据提取出来，get、post请求内容中则无需再写这些公共内容。比如提取url的公共部分、提取超时参数。\n\n```html\n<script src=\"https:unpkg.com.axios/dist/axios.min.js\"></script>\n<script>\n    axios.defaults.baseurl=\"http://-:8080/person\",\n    axios.defaults.timeout=3000,\n    axios.get('getall').then(res=>{ // == http://-:8080/person/getall\n        console.log(res)\n    })\n    axios.post('update').then(res=>{ // == http://-:8080/person/update\n        console.log(res)\n    })\n</script>\n```\n\n## 5. axios实例\n\n```html\n<script src=\"https:unpkg.com.axios/dist/axios.min.js\"></script>\n<script>\n    // 定义\n    let newVar = axios.create({\n        baseURL:'url',\n        timeout:5000\n    });\n    // 使用\n    newVar({\n        url:'getAll'\n    })\n\n</script>\n```\n\n## 6. 拦截器\n\n```html\n<script src=\"https:unpkg.com.axios/dist/axios.min.js\"></script>\n<script>\n   axios.interceptors.request.use(config=>{\n       // 进入前\n   },err=>{\n       // 发生错误\n   });\n</script>\n```\n\n## 7. 在vue中进行模块封装\n\n基于 import-export 来进行封装，类似函数封装\n\n> vue中安装axios:\n npm install axios --save\n\n### 7.1 无返回值\n\n🔹 封装内容 (位置 : /network/request/request.js):\n\n```js\nimport axios form 'axios'\nexport function request(url,success,fail){\n    axios({\n        url:url\n    }).then(res=>{\n        success(res)\n    }).catch(err=>{\n        fail(err)\n    })\n}\n```\n\n🔹 调用:\n\n```js\nimport {request} form './network/request/request.js'\nrequest(url,res=>{},err=>{})\n```\n\n### 7.2 返回Promise对象\n\nPromise中需声明、创建实例.\nPromise为ES6中的语法点，其内容代指即将发生的事件\n\n🔹 封装内容：\n\n```js\nimport axios form 'axios'\nexport function request(config){\n    return new Promise((resolve,reject)=>{\n        //声明实例\n        let newVar = axios.create({\n            baseURL:\"url\",\n            timeout:5000\n        });\n        //创建实例\n        newVar(config).then(res=>{\n            resolve(res)  //res将作为参数传给回调函数\n        }).catch(err=>{\n            reject(err)\n        })\n    })\n}\n```\n\n🔹 调用\n\n```js\nimport {request} form './network/request/request.js'\nrequest({url:'url'}).then(res=>{}).catch(err=>{})\n```\n\n### 7.3 返回实例\n\n方法内声明实例。本质同返回Promise对象\n\n🔹 封装内容：\n\n```js\nimport axios form 'axios'\nexport function request(config){\n    //声明实例\n    let newVar = axios.create({\n        baseURL:\"url\",\n        timeout:5000\n    });\n    //创建实例并返回\n    return newVar(config);\n}\n```\n\n🔹 调用\n\n```js\nimport {request} form './network/request/request.js'\nrequest({url:'url'}).then(res=>{}).catch(err=>{})\n```","tags":["前端 axios"],"categories":["前端","axios"]},{"title":"[总结]Java容器","url":"/2020/05/21/总结-Java容器/","content":"\n## 1. List、Map、Set\n\n🔹 List: 用于排序。元素有序、可重复。\n&emsp;&emsp;&emsp;&emsp;实现：Object数组 | 双向链表\n🔹 Map：用于搜索。存储键值对。key不可重复。\n&emsp;&emsp;&emsp;&emsp;实现：数组+链表（JDK1.8前），数组+链表+红黑树（JDK1.8~）\n🔹 Set：无重复（去重）。不可重复。\n&emsp;&emsp;&emsp;&emsp;实现：使用Map中的Key\n<!--more-->\n![collections/20200521153005](https://jianxi-md-pics.oss-cn-beijing.aliyuncs.com/note-md-imgs/collections/20200521153005.png?x-oss-process=image/resize,p_100/sharpen,50)\nRandomAccess：标记型接口。表示可随机访问元素（可快速访问）。\n\n## 2. List\n\n### 2.1 ArrayList、LinkedList 区别\n\n#### 2.1.1 底层实现\n\n🔹 ArrayList：<b>数组</b>\n🔹 LinkedList：<b>双向链表（1.7~）</b>，1.7之前是循环链表。\n\n循环链表相比双向链表的缺点：\n&emsp;1️⃣ 初始化时，需先创建一个空节点作为头节点，以避免需要多次校验头节点是否为null。\n&emsp;2️⃣ 头尾部节点不够清晰，且在头尾部分进行增删时，需处理头尾部两个节点的指针。\n\n#### 2.1.2 增删元素\n\n🔹 ArrayList：默认时，复杂度O(1)。指定位置时，复杂度O(n-i)。\n\n        增删某元素将对后续元素位置产生影响。不指定位置则默认增加到尾部。\n\n🔹 LinkedList: 复杂度O(1)。\n\n#### 2.1.3 查找元素\n\n🔹 ArrayList：可快速查询\n🔹 LinkedList：需遍历查询\n\n#### 2.1.4 线程安全性\n\n🔹 两者都是非线程安全的\n\n#### 2.1.5 空间占用\n\n🔹 ArrayList：需要预留容量空间\n🔹 LinkedList：每个节点需存储前继和后续节点的指针\n\n#### 2.1.6 扩容\n\n🔹 ArrayList：<b>+50%</b>,初始值10\n🔹 LinkedList：且无需扩容,无初始值\n\n### 2.2 ArrayList、Vector 区别\n\n#### 2.2.1 线程安全性\n\n🔹 ArrayList：非线程安全\n🔹 Vector：线程安全\n\n#### 2.2.2 效率\n\n🔹 ArrayList：效率更高\n🔹 Vector：效率低\n\n    Vector每个方法都添加了同步，即Synchronized。导致效率低。\n\n#### 2.2.3 扩容\n\n🔹 ArrayList：<b>增加 50%</b>，初始容量10\n🔹 Vector：<b>增加 100%</b>，初始容量10\n\n```java\n//ArrayList的grow中的增加的值\nint newCapacity = oldCapacity + (oldCapacity >> 1);\n```\n\n## 3. Map and Set\n\n### 3.1 HashMap 与 HashTable(不使用)\n\n#### 3.1.1 底层实现\n\n🔹 HashMap: <b>数组+红黑树+链表(1.8~)</b>,1.8前是数组+链表\n&emsp; jdk1.8，为了解决哈希冲突所带来的问题，当链表长度大于阈值(默认为8)，且当前长度不小于64，则将链表转为红黑树。若长度小于64，则是进行扩容。\n🔹 HashTable: <b>数组+链表</b>\n\n#### 3.1.2 线程安全性\n\n🔹 HashMap：<b>线程不安全</b>。若需线程安全可使用ConcurrentHashMap\n🔹 HashTable：<b>线程安全</b>。几乎大部分方法都加了同步\n\n#### 3.1.3 效率\n\n🔹 HashMap：效率高\n🔹 HashTable：效率低\n\n#### 3.1.4 扩容\n\n🔹 HashMap:增加一倍。初始值为16。扩容因子默认为0.75\n&emsp;若指定大小时，长度将为比该值稍大或等于的2的幂次方。这是由于hash%length==hash&(2^n-1)，且&的效率高于%。\n&emsp;eg: 指定值为50, 50 < 2^6. 故容量为2^6=16\n\n🔹 HashTable:增加一倍,再+1.初始值为11\n\n#### 3.1.5 null值的处理\n\n🔹 HashMap:key和value都支持null值，key仍不可重复\n🔹 HashTable:抛NullPointerException\n\n### 3.2 HashMap 与 HashSet\n\n#### 3.2.1 底层实现\n\nHashSet底层与HashMap一致，其内部调用了HashMap的方法。\n\n```java\n    //HashSet 中的代码：其中的方法实现是通过HashMap代理来实现\n    private transient HashMap<E,Object> map;\n    private static final Object PRESENT = new Object();\n\n    public int size() {\n        return map.size();\n    }\n\n    public boolean add(E e) {\n        return map.put(e, PRESENT)==null;\n    }\n```\n\n#### 3.2.2 对Hashcode的计算\n\n🔹 HashMap：根据key和value进行运算\n🔹 HashSet：没有重写HashCode方法，value值以空对象代替。\n```java\n    //该节点类为HashMap中内部类\n    static class Node<K, V> implements Entry<K, V> {\n         //key和value的地址进行异或运算（不同则1，相同则0）\n        public final int hashCode() {\n            return Objects.hashCode(this.key) ^ Objects.hashCode(this.value);\n        }\n        public final boolean equals(Object var1) {\n            if (var1 == this) {\n                return true;\n            } else {\n                if (var1 instanceof Entry) {\n                    Entry var2 = (Entry)var1;\n                    if (Objects.equals(this.key, var2.getKey()) && Objects.equals(this.value, var2.getValue())) {\n                        return true;\n                    }\n                }\n\n                return false;\n            }\n        }\n    }\n```\n\n### 📁内容补充：hashcode() 与 equals()\n\n🔹 Object中的hashcode()，是关于其该对象实例的内存地址。\n🔹 Map中，hashcode 相同，equals不一定相等，表示在同一个散列数据结构（链表）。equal相等，hashcode一定相等。\n🔹 由于hashcode存在冲突，故需要使用equals进行判断。\n\n### 3.3 ConcurrentHashMap 与 HashTable\n\n两者都是线程安全。HashTable几乎所有方法都添加了同步，效率低。\nJDK1.7的ConcurrentHashMap则是来取代HashTable。\n\n![collections/20200521144928](https://jianxi-md-pics.oss-cn-beijing.aliyuncs.com/note-md-imgs/collections/20200521144928.png?x-oss-process=image/resize,p_100/sharpen,50)\n\n#### 3.3.1 底层实现\n\n🔹 ConcurrentHashMap：同HashMap\n🔹 HashTable：数组+链表\n\n#### 3.3.2 线程安全的策略\n\n🔹 ConcurrentHashMap：<b>使用“分段式锁”</b>。\n&emsp;每一段数据分别加锁。而且加的锁是ReentrantLock可重入锁。\n![collections/20200521150144](https://jianxi-md-pics.oss-cn-beijing.aliyuncs.com/note-md-imgs/collections/20200521150144.png?x-oss-process=image/resize,p_70/sharpen,100)\n&emsp;[👉图片来源](https://www.cnblogs.com/chengxiao/p/6842045.html)\n\n🔹 HashTable：<b>大部分方法添加了同步</b>。如put/get方法添加了Synchronzed。\n&emsp;效率很低，近似整个容器对象添加了锁。\n![collections/20200521145945](https://jianxi-md-pics.oss-cn-beijing.aliyuncs.com/note-md-imgs/collections/20200521145945.png?x-oss-process=image/resize,p_70/sharpen,100)\n&emsp;[👉图片来源](https://www.cnblogs.com/chengxiao/p/6842045.html)\n","tags":["Java","Java容器"],"categories":["个人笔记","Java","基础","容器"]},{"title":"[总结]Git的基本使用","url":"/2020/05/13/总结-Git的基本使用/","content":"\n\n> Git作为一个版本控制的工具,在我们学习过程中是必不可少的。不仅是Git仓库GitHub、Gitee，还是在编辑器VSCode，Git在管理文件、控制文件版本、回退文件、多人协作、并发开发等有着重要的地位。\n>以下将对Git的基本使用继续总结、记录。\n<!--more-->\n## 1. Git与SVN的简单区分\n\n🔹 实现方式上\n&emsp;SVN : 集中版本控制。SVN所控制的所有版本内容存储在单一服务器上，本地用户在未联网的情况下，只能看到所同步的版本内容。\n&emsp;Git : 分布式版本控制。不同于SVN，本地的每个本地用户都能获取到所有版本内容，且Commit操作是在用户本地进，之后再push到远端仓库。\n&emsp;Git相比SVN，空间成本增加了，且安全性也有所下降，但也减少了数据损失而无法恢复的风险。\n\n🔹 克隆多分支项目\n&emsp;SVN克隆所有分支的内容\n&emsp;Git克隆master分支,其它分支只获取相关元素，节省了时间。\n\n## 2. Git的基本使用\n\n### 2.1 配置信息\n\n🔹 获取配置信息：\n\n```cs\n// 获取全部配置信息\ngit config -l\n// 获取系统级别配置信息，对应 \\git主目录\\etc\\gitconfig\ngit config --system -l\n// 获取用户(全局)级别的配置信息，对应 \\user\\Administrator\\.gitconfig\ngit config --global -l\n```\n\n🔹 配置全局的用户信息\n\n```cs\ngit config --global user.name \"用户名\"\ngit config --global user.email 邮箱\n```\n\n### 2.2 操作仓库内容\n\n🔹 初始化本地仓库\n\n```cs\ngit init\n```\n\n🔹 添加到缓存并提交到本地仓库\n\n```cs\ngit add .  \ngit commit -m \"注释\\提交的说明信息\"  \n```\n\n🔹 提交到远程仓库\n\n```cs\ngit push 地址 master\n```\n\n🔹 克隆远程仓库 \\ 获取远程代码\n\n```cs\ngit clone 地址 分支(eg:master)\ngit pull 地址 分支(eg:master)\n```\n\n🔹 查看本地文件状态\n\n```cs\ngit status\n```\n![git/20200513120026](https://jianxi-md-pics.oss-cn-beijing.aliyuncs.com/note-md-imgs/git/20200513120026.png?x-oss-process=image/resize,p_80/sharpen,100)\n\n## 3.HEAD\n\nHEAD 指当前分支的最近一次提交\nhead 指commit对象\n\nhead 包含 HEAD\n\n🔹 占位符 ~ 与 ^\n\n\\~ ： 表示祖先commit\n&emsp;&emsp;eg : HEAD\\~ = HEAD\\~1 = 前一代commit（父辈）\n&emsp;&emsp;&emsp;HEAD\\~\\~ = HEAD\\~2 = 前两代commit（爷爷辈）\n^ :  单个父辈时，与 \\~ 基本一致。\n&emsp;&emsp;多个父辈时，^ = ^1 = 第一个父辈\n\n🔹 案例\n\n![git/20200512233813](https://jianxi-md-pics.oss-cn-beijing.aliyuncs.com/note-md-imgs/git/20200512233813.png?x-oss-process=image/resize,p_70/sharpen,100)\n\n```cs\nG   H   I   J\n \\ /     \\ /\n  D   E   F\n   \\  |  / \\\n    \\ | /   |\n     \\|/    |\n      B     C\n       \\   /\n        \\ /\n         A\nA =      = A^0\nB = A^   = A^1     = A~1\nC = A^2  = A^2\nD = A^^  = A^1^1   = A~2\nE = B^2  = A^^2\nF = B^3  = A^^3\nG = A^^^ = A^1^1^1 = A~3\nH = D^2  = B^^2    = A^^^2  = A~2^2\nI = F^   = B^3^    = A^^3^\nJ = F^2  = B^3^2   = A^^3^2\n\n```\n\n[👉此内容参考来源](https://scarletsky.github.io/2016/12/29/tilde-and-caret-in-git/)\n\n## 4. 信息查看\n\n🔹 获取本地文件状态\n\n```cs\ngit status\n```\n\n🔹 获取commit历史信息\n\n```cs\ngit log\ngit log --oneline\n```\n\n🔹 查看当前索引(暂存区)\n\n```cs\ngit ls-files -s\n```\n\n🔹 显示了 HEAD 快照实际的目录列表\n\n```cs\ngit cat-file -p HEAD\n```\n\n🔹 查看HEAD的当前指向\n\n```cs\ncat .git/HEAD\n```\n\n🔹 查看HEAD各个祖先\n\n```cs\ngit rev-parse HEAD~ //前一个祖先(父辈)\n```\n\n## 5. 撤销操作\n\n🔹 git checkout [不写|HEAD] \\<file> //旧版\n\n🔹 git  restore [不写|--staged] \\<file> //新版\n\n🔹 git reset [--hard|soft|mixed(默认)|merge|keep] [commit|HEAD]\n(1) --soft : 回退到暂存区状态\n(2) --mixed : 回退到本地状态（本地修改的内容存在）\n(3) --hard : 回退到某次提交，清除所有历史状态，包括本地文件内容。\n\n🔹 git revert HEAD^\n    重新提交，保留历史记录\n    git reset不保留历史记录\n    ![git/20200513010450](https://jianxi-md-pics.oss-cn-beijing.aliyuncs.com/note-md-imgs/git/20200513010450.png?x-oss-process=image/resize,p_70/sharpen,100)\n    ![git/20200513120122](https://jianxi-md-pics.oss-cn-beijing.aliyuncs.com/note-md-imgs/git/20200513120122.png?x-oss-process=image/resize,p_90/sharpen,100)\n\n🔹 重写最后一次commit\n\n```cs\n git commit --amend -m\n```\n\n![git/20200513143620_](https://jianxi-md-pics.oss-cn-beijing.aliyuncs.com/note-md-imgs/git/20200513143620_.png?x-oss-process=image/resize,p_100/sharpen,50)\n\n## 6. 冲突解决\n\n🔹 提交时，发生冲突\n\n执行git pull，发生冲突后，git会将两个版本的内容合并在一起。\n解决：先git status，查找发生冲突的文件，自行修改冲突内容后再提交，pull\n\n🔹 回退commit，发生冲突\n\n执行revert HEAD^，发生冲突。\n解决：同样查看冲突、修改冲突后，执行git revert --continue。\n\n## 7. Git的分支处理\n\n🔹 常用命令\n\n```cs\n\n# 列出所有本地分支\ngit branch\n\n# 列出所有远程分支\ngit branch -r\n\n# 新建一个分支，但依然停留在当前分支\ngit branch [branch-name]\n\n# 新建一个分支，并切换到该分支\ngit checkout -b [branch]\n\n# 切换分支\ngit checkout [branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n\n```\n\n[👉此内容来源](https://mp.weixin.qq.com/s/Bf7uVhGiu47uOELjmC5uXQ)\n\n>参考文章：\n[狂神说 聊Git📘](https://mp.weixin.qq.com/s/Bf7uVhGiu47uOELjmC5uXQ)\n[CSDN 奋飛 Git Pro深入浅出（二）📘](https://blog.csdn.net/ligang2585116/article/details/51816372#t7)\n","tags":["版本控制","Git"],"categories":["个人笔记","工具","版本控制","Git"]},{"title":"[总结]CSS样式失效的原因","url":"/2020/05/11/总结-CSS样式失效的原因/","content":"\nCSS样式生效，需要正确的语法，并且其样式内容不被覆盖。\n以下先总结三点原因（后续再补充）：\n🔹 错误使用单行注释\n🔹 CSS选择器优先级较低\n🔹 Chrome浏览器存在CSS文件缓存\n<!--more-->\n## 1. 在外部CSS中不能使用单行注释\n\n在CSS选择器上使用单行注释，将导致该注释下的这个CSS选择器里面的内容失效。\n如下代码所示,“.post-readmore__link{}”将失效,“.post-readmore__link:hover{}”有效，不会受到影响。\n\n```css\n//readmore button （第一个CSS选择器无效）\n.post-readmore__link{\n    background-color: #27ae60;\n}\n.post-readmore__link:hover{\n    background-color: #1f7f47;\n}\n```\n\n而单行注释添加在CSS样式内，该CSS仍有效\n\n```css\n.post-readmore__link{\n    background-color: #27ae60; //green （有效）\n}\n```\n\n若需要使用注释，可使用多行注释。如下：\n\n```css\n/* readmore button */\n.post-readmore__link{\n    background-color: #27ae60; //green （有效）\n}\n```\n\n## 2. CSS选择器优先级低于原有的CSS选择器\n\n### 2.1. 当多个CSS选择器选择目标相同时\n\n🔹 级别相同，后加载的CSS选择器覆盖前CSS选择器中相同的样式。\n🔹 级别不同，高级别CSS选择器覆盖低级别CSS选择器中相同的样式。\n\n### 2.2. 级别判断\n\n🔹 内嵌式CSS级别高于外部CSS，可视为最高级别。\n\n🔹 <b>#ID</b> > <b>.Class</b>、属性选择器([type=\"button\"])和伪类(:hover)  >  <b>标签</b>类型和伪元素(::after)\n级别计算案例：\n![keng/CSS/20200511114245](https://jianxi-md-pics.oss-cn-beijing.aliyuncs.com/note-md-imgs/keng/CSS/20200511114245.png?x-oss-process=image/resize,p_100/sharpen,50)\n图片内容来源：[MDN Web Docs](https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Cascade_and_inheritance#Specificity_2)\n\n🔹 使用!important覆盖任何样式声明\n\n```css\n.post-readmore__link{\n    background-color: #27ae60 !important;\n}\n```\n\n对于都添加！important的样式，则再由其选择器优先级来判断。\n\n## 3.chrome浏览器存在缓存\n\n🔹 原因:\n&emsp;&emsp;chrome浏览器为了提高加载效率，缓存了JS、CSS文件，故修改后的文件无法立即生效。\n\n🔹 解决方法：\n方式一：来回切换开启缓存来重置缓存内容（不一定有效）。\n&emsp;&emsp;F12打开开发者工具，进入Network，在Disable cache前打勾✔，刷新页面。再把Disable cache关闭，取消✔，再次刷新页面。\n\n![keng/CSS/20200511130923](https://jianxi-md-pics.oss-cn-beijing.aliyuncs.com/note-md-imgs/keng/CSS/20200511130923.png?x-oss-process=image/resize,p_100/sharpen,50)\n\n方式二：来回切换开启缓存来重置缓存内容\n&emsp;&emsp;F12打开开发者工具，然后在浏览器的刷新按钮右击，选择“清空缓存并硬性重新加载”\n\n![keng/CSS/20200511154213](https://jianxi-md-pics.oss-cn-beijing.aliyuncs.com/note-md-imgs/keng/CSS/20200511154213.png?x-oss-process=image/resize,p_100/sharpen,50)\n","tags":["前端","CSS"],"categories":["踩坑记录","前端","CSS"]},{"title":"个人博客[2]——美化","url":"/2020/05/11/个人博客-2-——美化/","content":"\n> 环境要求：node.js 和 npm\n> 基于 Hexo博客框架\n> 基于 Hexo主题stun\n\n美化内容以下：\n🔹 主题设置\n🔹 博客主题样式自定义\n🔹 博客文章样式自定义\n<!--more-->\n\n效果图：\n![博客/20200510162900](https://jianxi-md-pics.oss-cn-beijing.aliyuncs.com/note-md-imgs/博客/20200510162900.png?x-oss-process=image/resize,p_100/sharpen,50)\n\n[👉Hexo官方地址](https://hexo.io/zh-cn/index.html)  [👉Hexo-theme-stun官方地址](https://liuyib.github.io/hexo-theme-stun/zh-CN/)\n\n## 1. 修改主题\n\n### 1.1. 下载主题(stun)\n\ngit clone <https://github.com/liuyib/hexo-theme-stun.git> themes/stun\n\n### 1.2. 配置主题\n\n修改_config.yml\n\n    ```yml\n        #Extensions\n        ...\n        theme: yilia\n    ```\n\n### 1.3. Hexo重设与发布\n\n    清除 hexo clean\n    创建 hexo g\n    启动 hexo s\n    推到远端 hexo d\n\n## 2. 基本样式修改\n\n主题的相关设置详见[官方文档📗](https://liuyib.github.io/hexo-theme-stun/zh-CN/guide/primary.html#%E7%BD%91%E7%AB%99%E9%A1%B6%E9%83%A8%E8%AE%BE%E7%BD%AE)\n\n可修改Hexo主路径下的_config.yml,将生效于所有主题。\n也可修改hexo/theme/stun下的_config.xml,将只生效于stun主题。\n\n### 2.1. 修改博客图标等图片\n\n🔹 方式一：覆盖原图像\n\n在Hexo主路径下的\\themes\\stun\\source\\images\\icons中，使用相同大小的图片覆盖。之后查看stun下的_config.xml是否开启对应的功能。\n\n🔹 方式二：自定义路径\n\n在_config.xml相应的配置下，设置图片路径为自定义图片路径（Hexo下的路径、图床上的路径）\n\n### 2.2. 修改网页样式\n\n🔹 修改文章样式\n\n将CSS样式添加到stun主题的路径下的\\source\\css\\_custom\\index.styl文件内即可。\n内容如下：\n\n```css\n// Custom styles by yourself.\n// You should always modify the style here,\n    not in the source code.\n// Otherwise, when the theme is updated,\n    the code you modified will be overwritten.\nbody {\n  // modify your style here\n  // eg: background-color: blue;  \n\n    h1 {\n      text-align: center;\n    }\n    h1, h2{\n      color: #4CAF50;\n    }\n    ...\n}\n```\n\n🔹 修改博客样式\n\n（1）在stun主题的路径下的\\source\\css创建文件夹，自定义名称，名称前需带\"_\"，例如：_myCss。在该创建的文件夹下放置个人的CSS文件。\n（2）配置CSS文件。\n在stun\\source\\css\\index.styl文件内添加以下内容：\n@import '个人的CSS文件全路径'\n如下：\n\n```css\n// Variables Layer\n// --------------------------------------------------\n@import './_variables/index.styl';\n// Mixins Layer\n// --------------------------------------------------\n@import './_mixins/index.styl';\n// Common Layer\n// --------------------------------------------------\n@import './_common/index.styl';\n// Custom Layer\n// --------------------------------------------------\n@import './_custom/index.styl';\n\n// MyCSS\n// --------------------------------------------------\n@import './_myCss/myCss.css';\n```\n","tags":["个人博客"],"categories":["个人博客"]},{"title":"个人博客[3]——写作","url":"/2020/05/11/个人博客-3-——写作/","content":"\n> 环境要求：node.js 和 npm\n> 基于 Hexo博客框架\n> 基于 Hexo主题stun\n\n本文内容包含：\n🔹 创建、修改、删除文章\n🔹 创建分类、标签页面\n🔹 在stun主题内开启分页和标签页面\n<!--more-->\n## 1. 创建\n\n具体操作见[官方文档📗](https://hexo.io/zh-cn/docs/writing)\n\n### 1.1. 创建文章\n\n```cmd\nhexo n \"文章名称\"\nhexo c & hexo g\n```\n\n### 1.2. 创建分类、标签页面（即创建页面）\n\n🔹 创建分类页面\n\n在Hexo主路径下，执行以下命令\n\n```cmd\n    hexo new page categories\n```\n\n在文章编写时，在文章顶部的Front-matter添加分类信息：\n\n```yml\n    categories：\n        - 分类名称\n        - 下一级分类名称\n        - [同级分类名称...]\n```\n\n🔹 创建标签页面\n\n与创建分页页面相同，将categories改为tags即可。\n不同的是，Front-matter中的tags没有分级。\n\n例子：\n\n```yml\n---\ntitle: '个人博客[1]——搭建'\ndate: 2020-05-10 17:39:21\ntags:\n    个人博客\ncategories:\n    - 个人博客\nphotos:\n    - url\n---\n```\n\n🔹 在stun主题内开启分页和标签页面\n\n在stun主路径下的_config.yml配置文件的menu节点下添加页面配置信息，如下\n\n```yml\nmenu:\n  home: / || fas fa-home\n  archives: /archives/ || fas fa-folder-open\n  categories: /categories/ || fas fa-layer-group\n  tags: /tags/ || fas fa-tags\n  # You can add a secondary menu like follow.\n  # xxx1: javascript:; || fa(s|r|l|d|b) fa-xxx\n```\n\n效果图：\n![博客/20200511143752](https://jianxi-md-pics.oss-cn-beijing.aliyuncs.com/note-md-imgs/博客/20200511143752.png?x-oss-process=image/resize,p_100/sharpen,50)\n\n## 2.修改\n\n### 2.1. 修改文章名称\n\n&emsp;&emsp;Hexo未提供修改文件名称的命令。\n\n🔹 解决方法：\n\n&emsp;&emsp;最简单的方式就是重新创建该文章，将要修改文章迁移过去。单独修改文章名称和修改文章内的Title标签是无效的。\n&emsp;&emsp;也可使用hexo-console-renamer插件，后续使用后再来补充。\n\n### 2.2 删除文章\n\n&emsp;&emsp;同样的，Hexo未提供删除文章的命令。\n\n🔹 解决方法：\n\n&emsp;&emsp;在Hexo主路径下的\\source\\_posts文件夹内，手动删除文章文件，之后再重新创建博客内容，即运行以下命令\n\n```cmd\nhexo c & hexo g\n```","tags":["个人博客"],"categories":["个人博客"]},{"title":"个人博客[1]——搭建","url":"/2020/05/10/个人博客-1-——搭建/","content":"\n\n> 环境要求：node.js 和 npm\n> 基于 Hexo博客框架\n\n[👉Hexo官方地址](https://hexo.io/zh-cn/index.html)\n<!-- more -->\n## 1. 配置环境\n\n安装node.js和npm\n修改npm的镜像为阿里镜像，即按照cnpm\n\n- <b>安装cnpm</b>\n    cmd命令：\n    &emsp;&emsp;npm install -g cnpm --registry=<https://registry.npm.taobao.org>\n    安装测试：\n    &emsp;&emsp;cnpm -v\n\n    ![20200509224340](https://jianxi-md-pics.oss-cn-beijing.aliyuncs.com/note-md-imgs/博客/20200509224340.png?x-oss-process=image/resize,p_70/sharpen,100)\n\n## 2. 安装Hexo框架\n\n2.1. 安装：cnpm install -g hero-cli\n   ![博客/20200509230904](https://jianxi-md-pics.oss-cn-beijing.aliyuncs.com/note-md-imgs/博客/20200509230904.png?x-oss-process=image/resize,p_100/sharpen,50)\n\n2.2. 验证安装：hexo -v\n    ![博客/20200509230612](https://jianxi-md-pics.oss-cn-beijing.aliyuncs.com/note-md-imgs/博客/20200509230612.png?x-oss-process=image/resize,p_100/sharpen,50)\n\n## 3. 初始化Hexo博客\n\n3.1. 初始化hexo项目：hexo init\n![博客/20200509234848](https://jianxi-md-pics.oss-cn-beijing.aliyuncs.com/note-md-imgs/博客/20200509234848.png?x-oss-process=image/resize,p_70/sharpen,100)\n\n3.2. 启动项目：hexo s\n![博客/20200510005009](https://jianxi-md-pics.oss-cn-beijing.aliyuncs.com/note-md-imgs/博客/20200510005009.png?x-oss-process=image/resize,p_70/sharpen,100)\n\n## 4. 添加第一篇文章\n\n[👉Hexo官方:写作](https://hexo.io/zh-cn/docs/writing)\n\n1. 创建新文章：hexo n 文件名\n2. 清理：hexo clean\n3. 生成文章：hexo g\n4. 重启：hexo s\n\n## 5. 部署到GitHub上\n\n5.1. 创建git仓库,名称为 \"git账号名.github.io\"\n5.2. 安装github部署插件。\n    在本地博客路径下，运行 cnpm install --save hexo-deployer-git\n    ![博客/20200510010947](https://jianxi-md-pics.oss-cn-beijing.aliyuncs.com/note-md-imgs/博客/20200510010947.png?x-oss-process=image/resize,p_90/sharpen,100)\n5.3. 添加仓库信息\n    修改_config.yml。\n    在#deployment节点下，内容如下：\n    ==冒号后需 + 空格==\n\n    ```yml\n    #deployment\n    deploy:\n        type: git\n        repo: 仓库地址\n        branch: master\n    ```\n\n5.4. 部署到远端\n    hexo d\n    ![博客/20200510010628](https://jianxi-md-pics.oss-cn-beijing.aliyuncs.com/note-md-imgs/博客/20200510010628.png?x-oss-process=image/resize,p_100/sharpen,50)\n","tags":["个人博客"],"categories":["个人博客"]}]